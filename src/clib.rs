/* automatically generated by rust-bindgen */

/**
 * \brief Environment initialization options
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct spdk_env_opts {
    pub name: *const ::std::os::raw::c_char,
    pub core_mask: *const ::std::os::raw::c_char,
    pub shm_id: ::std::os::raw::c_int,
    pub dpdk_mem_channel: ::std::os::raw::c_int,
    pub dpdk_master_core: ::std::os::raw::c_int,
    pub dpdk_mem_size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_spdk_env_opts() {
    assert_eq!(::std::mem::size_of::<spdk_env_opts>() , 32usize , concat ! (
               "Size of: " , stringify ! ( spdk_env_opts ) ));
    assert_eq! (::std::mem::align_of::<spdk_env_opts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( spdk_env_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . core_mask as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( core_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . shm_id as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( shm_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . dpdk_mem_channel as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( dpdk_mem_channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . dpdk_master_core as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( dpdk_master_core ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . dpdk_mem_size as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( dpdk_mem_size ) ));
}
impl Clone for spdk_env_opts {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_env_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    /**
 * \brief Initialize the default value of opts
*/
    pub fn spdk_env_opts_init(opts: *mut spdk_env_opts);
}
extern "C" {
    /**
 * \brief Initialize the environment library. This must be called prior to using
 * any other functions in this library.
*/
    pub fn spdk_env_init(opts: *const spdk_env_opts);
}
extern "C" {
    /**
 * Allocate a pinned, physically contiguous memory buffer with the
 *   given size and alignment.
 */
    pub fn spdk_malloc(size: usize, align: usize, phys_addr: *mut u64)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Allocate a pinned, physically contiguous memory buffer with the
 *   given size and alignment. The buffer will be zeroed.
 */
    pub fn spdk_zmalloc(size: usize, align: usize, phys_addr: *mut u64)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Resize the allocated and pinned memory buffer with the given
 *   new size and alignment. Existing contents are preserved.
 */
    pub fn spdk_realloc(buf: *mut ::std::os::raw::c_void, size: usize,
                        align: usize, phys_addr: *mut u64)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Free a memory buffer previously allocated with spdk_zmalloc.
 *   This call is never made from the performance path.
 */
    pub fn spdk_free(buf: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_mempool([u8; 0]);
extern "C" {
    /**
 * Create a thread-safe memory pool. Cache size is the number of
 * elements in a thread-local cache. Can be 0 for no caching, or -1
 * for unspecified.
 *
 * \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.
 */
    pub fn spdk_mempool_create(name: *const ::std::os::raw::c_char,
                               count: usize, ele_size: usize,
                               cache_size: usize,
                               socket_id: ::std::os::raw::c_int)
     -> *mut spdk_mempool;
}
extern "C" {
    /**
 * Free a memory pool.
 */
    pub fn spdk_mempool_free(mp: *mut spdk_mempool);
}
extern "C" {
    /**
 * Get an element from a memory pool. If no elements remain, return NULL.
 */
    pub fn spdk_mempool_get(mp: *mut spdk_mempool)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Put an element back into the memory pool.
 */
    pub fn spdk_mempool_put(mp: *mut spdk_mempool,
                            ele: *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * Put multiple elements back into the memory pool.
 */
    pub fn spdk_mempool_put_bulk(mp: *mut spdk_mempool,
                                 ele_arr:
                                     *const *const ::std::os::raw::c_void,
                                 count: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_mem_map([u8; 0]);
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_mem_map_notify_action {
    SPDK_MEM_MAP_NOTIFY_REGISTER = 0,
    SPDK_MEM_MAP_NOTIFY_UNREGISTER = 1,
}
pub type spdk_mem_map_notify_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               map: *mut spdk_mem_map,
                                               action:
                                                   spdk_mem_map_notify_action,
                                               vaddr:
                                                   *mut ::std::os::raw::c_void,
                                               size: usize)>;
extern "C" {
    /**
 * Allocate a virtual memory address translation map
 */
    pub fn spdk_mem_map_alloc(default_translation: u64,
                              notify_cb: spdk_mem_map_notify_cb,
                              cb_ctx: *mut ::std::os::raw::c_void)
     -> *mut spdk_mem_map;
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cap_register {
    pub raw: u64,
    pub bits: spdk_nvme_cap_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cap_register__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub _bitfield_2: [u8; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cap_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cap_register__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_cap_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cap_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cap_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_cap_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_cap_register__bindgen_ty_1 {
    #[inline]
    pub fn mqes(&self) -> u32 {
        let mask = 65535usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mqes(&mut self, val: u32) {
        let mask = 65535usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn cqr(&self) -> u32 {
        let mask = 65536usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_cqr(&mut self, val: u32) {
        let mask = 65536usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn ams(&self) -> u32 {
        let mask = 393216usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ams(&mut self, val: u32) {
        let mask = 393216usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 17usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 16252928usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 16252928usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 19usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn to(&self) -> u32 {
        let mask = 4278190080usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_to(&mut self, val: u32) {
        let mask = 4278190080usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 24usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn dstrd(&self) -> u32 {
        let mask = 15usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dstrd(&mut self, val: u32) {
        let mask = 15usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn nssrs(&self) -> u32 {
        let mask = 16usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_nssrs(&mut self, val: u32) {
        let mask = 16usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn css_nvm(&self) -> u32 {
        let mask = 32usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_css_nvm(&mut self, val: u32) {
        let mask = 32usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn css_reserved(&self) -> u32 {
        let mask = 448usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_css_reserved(&mut self, val: u32) {
        let mask = 448usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 6usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mask = 65024usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 65024usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 9usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn mpsmin(&self) -> u32 {
        let mask = 983040usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mpsmin(&mut self, val: u32) {
        let mask = 983040usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 16usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn mpsmax(&self) -> u32 {
        let mask = 15728640usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mpsmax(&mut self, val: u32) {
        let mask = 15728640usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 20usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        let mask = 4278190080usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        let mask = 4278190080usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 24usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cap_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cap_register>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_cap_register )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cap_register>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cap_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cap_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cap_register
                ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cap_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cap_register
                ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_cap_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cap_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cc_register {
    pub raw: u32,
    pub bits: spdk_nvme_cc_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cc_register__bindgen_ty_1 {
    pub _bitfield_1: [u8; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cc_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cc_register__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cc_register__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cc_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cc_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_cc_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_cc_register__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        let mask = 1usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 14usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 14usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn css(&self) -> u32 {
        let mask = 112usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_css(&mut self, val: u32) {
        let mask = 112usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn mps(&self) -> u32 {
        let mask = 1920usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: u32) {
        let mask = 1920usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 7usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn ams(&self) -> u32 {
        let mask = 14336usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ams(&mut self, val: u32) {
        let mask = 14336usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 11usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn shn(&self) -> u32 {
        let mask = 49152usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_shn(&mut self, val: u32) {
        let mask = 49152usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 14usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn iosqes(&self) -> u32 {
        let mask = 983040usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_iosqes(&mut self, val: u32) {
        let mask = 983040usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn iocqes(&self) -> u32 {
        let mask = 15728640usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_iocqes(&mut self, val: u32) {
        let mask = 15728640usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 20usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mask = 4278190080usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 4278190080usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 24usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cc_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cc_register>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_cc_register )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cc_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cc_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cc_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cc_register )
                , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cc_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cc_register )
                , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_cc_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cc_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_shn_value {
    SPDK_NVME_SHN_NORMAL = 1,
    SPDK_NVME_SHN_ABRUPT = 2,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_csts_register {
    pub raw: u32,
    pub bits: spdk_nvme_csts_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_csts_register__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_csts_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_csts_register__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_csts_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_csts_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_csts_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_csts_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_csts_register__bindgen_ty_1 {
    #[inline]
    pub fn rdy(&self) -> u32 {
        let mask = 1usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rdy(&mut self, val: u32) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn cfs(&self) -> u32 {
        let mask = 2usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_cfs(&mut self, val: u32) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn shst(&self) -> u32 {
        let mask = 12usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_shst(&mut self, val: u32) {
        let mask = 12usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 4294967280usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 4294967280usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_csts_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_csts_register>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_csts_register ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_csts_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_csts_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_csts_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_csts_register
                ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_csts_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_csts_register
                ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_csts_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_csts_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_shst_value {
    SPDK_NVME_SHST_NORMAL = 0,
    SPDK_NVME_SHST_OCCURRING = 1,
    SPDK_NVME_SHST_COMPLETE = 2,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_aqa_register {
    pub raw: u32,
    pub bits: spdk_nvme_aqa_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_aqa_register__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_aqa_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_aqa_register__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_aqa_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_aqa_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_aqa_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_aqa_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_aqa_register__bindgen_ty_1 {
    #[inline]
    pub fn asqs(&self) -> u32 {
        let mask = 4095usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_asqs(&mut self, val: u32) {
        let mask = 4095usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 61440usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 61440usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 12usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn acqs(&self) -> u32 {
        let mask = 268369920usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_acqs(&mut self, val: u32) {
        let mask = 268369920usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mask = 4026531840usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 4026531840usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 28usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_aqa_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_aqa_register>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_aqa_register )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_aqa_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_aqa_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_aqa_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_aqa_register
                ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_aqa_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_aqa_register
                ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_aqa_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_aqa_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_vs_register {
    pub raw: u32,
    pub bits: spdk_nvme_vs_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_vs_register__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_vs_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_vs_register__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_vs_register__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_vs_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_vs_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_vs_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_vs_register__bindgen_ty_1 {
    #[inline]
    pub fn ter(&self) -> u32 {
        let mask = 255usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ter(&mut self, val: u32) {
        let mask = 255usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn mnr(&self) -> u32 {
        let mask = 65280usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mnr(&mut self, val: u32) {
        let mask = 65280usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn mjr(&self) -> u32 {
        let mask = 4294901760usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mjr(&mut self, val: u32) {
        let mask = 4294901760usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_vs_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_vs_register>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_vs_register )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_vs_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_vs_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_vs_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_vs_register )
                , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_vs_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_vs_register )
                , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_vs_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_vs_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cmbloc_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbloc_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cmbloc_register__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbloc_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmbloc_register__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_cmbloc_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmbloc_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cmbloc_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_cmbloc_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_cmbloc_register__bindgen_ty_1 {
    #[inline]
    pub fn bir(&self) -> u32 {
        let mask = 7usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bir(&mut self, val: u32) {
        let mask = 7usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 4088usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 4088usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn ofst(&self) -> u32 {
        let mask = 4294963200usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ofst(&mut self, val: u32) {
        let mask = 4294963200usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 12usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbloc_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmbloc_register>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cmbloc_register ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmbloc_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cmbloc_register )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmbloc_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmbloc_register ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmbloc_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmbloc_register ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_cmbloc_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cmbloc_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cmbsz_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbsz_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cmbsz_register__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsz_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmbsz_register__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_cmbsz_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmbsz_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cmbsz_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_cmbsz_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_cmbsz_register__bindgen_ty_1 {
    #[inline]
    pub fn sqs(&self) -> u32 {
        let mask = 1usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sqs(&mut self, val: u32) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn cqs(&self) -> u32 {
        let mask = 2usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_cqs(&mut self, val: u32) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn lists(&self) -> u32 {
        let mask = 4usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lists(&mut self, val: u32) {
        let mask = 4usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn rds(&self) -> u32 {
        let mask = 8usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rds(&mut self, val: u32) {
        let mask = 8usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn wds(&self) -> u32 {
        let mask = 16usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_wds(&mut self, val: u32) {
        let mask = 16usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 224usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 224usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn szu(&self) -> u32 {
        let mask = 3840usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_szu(&mut self, val: u32) {
        let mask = 3840usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn sz(&self) -> u32 {
        let mask = 4294963200usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sz(&mut self, val: u32) {
        let mask = 4294963200usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 12usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsz_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmbsz_register>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cmbsz_register ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmbsz_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cmbsz_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmbsz_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmbsz_register ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmbsz_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmbsz_register ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_cmbsz_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cmbsz_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct spdk_nvme_registers {
    /** controller capabilities */
    pub cap: spdk_nvme_cap_register,
    /** version of NVMe specification */
    pub vs: spdk_nvme_vs_register,
    pub intms: u32,
    pub intmc: u32,
    /** controller configuration */
    pub cc: spdk_nvme_cc_register,
    pub reserved1: u32,
    pub csts: spdk_nvme_csts_register,
    pub nssr: u32,
    /** admin queue attributes */
    pub aqa: spdk_nvme_aqa_register,
    pub asq: u64,
    pub acq: u64,
    /** controller memory buffer location */
    pub cmbloc: spdk_nvme_cmbloc_register,
    /** controller memory buffer size */
    pub cmbsz: spdk_nvme_cmbsz_register,
    pub reserved3: [u32; 1008usize],
    pub doorbell: [spdk_nvme_registers__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_registers__bindgen_ty_1 {
    pub sq_tdbl: u32,
    pub cq_hdbl: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_registers__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_registers__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_registers__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_registers__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_registers__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers__bindgen_ty_1 ) ) .
                sq_tdbl as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_registers__bindgen_ty_1 ) , "::" , stringify ! (
                sq_tdbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers__bindgen_ty_1 ) ) .
                cq_hdbl as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_registers__bindgen_ty_1 ) , "::" , stringify ! (
                cq_hdbl ) ));
}
impl Clone for spdk_nvme_registers__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_spdk_nvme_registers() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_registers>() , 4104usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_registers )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_registers>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_registers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . cap as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . vs as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( vs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . intms as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( intms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . intmc as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( intmc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . cc as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( cc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . reserved1 as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . csts as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( csts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . nssr as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( nssr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . aqa as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( aqa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . asq as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( asq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . acq as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( acq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . cmbloc as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( cmbloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . cmbsz as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( cmbsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . reserved3 as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . doorbell as *
                const _ as usize } , 4096usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( doorbell ) ));
}
impl Default for spdk_nvme_registers {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_sgl_descriptor_type {
    SPDK_NVME_SGL_TYPE_DATA_BLOCK = 0,
    SPDK_NVME_SGL_TYPE_BIT_BUCKET = 1,
    SPDK_NVME_SGL_TYPE_SEGMENT = 2,
    SPDK_NVME_SGL_TYPE_LAST_SEGMENT = 3,
    SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK = 4,
    SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_sgl_descriptor_subtype {
    SPDK_NVME_SGL_SUBTYPE_ADDRESS = 0,
    SPDK_NVME_SGL_SUBTYPE_OFFSET = 1,
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct spdk_nvme_sgl_descriptor {
    pub address: u64,
    pub __bindgen_anon_1: spdk_nvme_sgl_descriptor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    pub generic: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1,
    pub unkeyed: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2,
    pub keyed: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub reserved: [u8; 7usize],
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ) .
                reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( reserved ) ));
}
impl Clone for spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn subtype(&self) -> u8 {
        let mask = 15usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u8) {
        let mask = 15usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        let mask = 240usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        let mask = 240usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    pub length: u32,
    pub reserved: [u8; 3usize],
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ) .
                length as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ) .
                reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( reserved ) ));
}
impl Clone for spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn subtype(&self) -> u8 {
        let mask = 15usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u8) {
        let mask = 15usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        let mask = 240usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        let mask = 240usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_1: [u32; 2usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ) ));
}
impl Clone for spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn length(&self) -> u64 {
        let mask = 16777215usize as u64;
        let field_val: u64 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u64) {
        let mask = 16777215usize as u64;
        let val = val as u64 as u64;
        let mut field_val: u64 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn key(&self) -> u64 {
        let mask = 72057594021150720usize as u64;
        let field_val: u64 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_key(&mut self, val: u64) {
        let mask = 72057594021150720usize as u64;
        let val = val as u64 as u64;
        let mut field_val: u64 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 24usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn subtype(&self) -> u64 {
        let mask = 1080863910568919040usize as u64;
        let field_val: u64 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 56usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u64) {
        let mask = 1080863910568919040usize as u64;
        let val = val as u64 as u64;
        let mut field_val: u64 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 56usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn type_(&self) -> u64 {
        let mask = 17293822569102704640usize as u64;
        let field_val: u64 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 60usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u64) {
        let mask = 17293822569102704640usize as u64;
        let val = val as u64 as u64;
        let mut field_val: u64 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 60usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_sgl_descriptor__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_sgl_descriptor__bindgen_ty_1 )
                ) . generic as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1 ) , "::" , stringify !
                ( generic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_sgl_descriptor__bindgen_ty_1 )
                ) . unkeyed as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1 ) , "::" , stringify !
                ( unkeyed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_sgl_descriptor__bindgen_ty_1 )
                ) . keyed as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1 ) , "::" , stringify !
                ( keyed ) ));
}
impl Clone for spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_sgl_descriptor ) ) . address as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor ) , "::" , stringify ! ( address )
                ));
}
impl Clone for spdk_nvme_sgl_descriptor {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_sgl_descriptor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_psdt_value {
    SPDK_NVME_PSDT_PRP = 0,
    SPDK_NVME_PSDT_SGL_MPTR_CONTIG = 1,
    SPDK_NVME_PSDT_SGL_MPTR_SGL = 2,
    SPDK_NVME_PSDT_RESERVED = 3,
}
#[repr(u32)]
/**
 * Submission queue priority values for Create I/O Submission Queue Command.
 *
 * Only valid for weighted round robin arbitration method.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_qprio {
    SPDK_NVME_QPRIO_URGENT = 0,
    SPDK_NVME_QPRIO_HIGH = 1,
    SPDK_NVME_QPRIO_MEDIUM = 2,
    SPDK_NVME_QPRIO_LOW = 3,
}
#[repr(u32)]
/**
 * Optional Arbitration Mechanism Supported by the controller.
 *
 * Two bits for CAP.AMS (18:17) field are set to '1' when the controller supports.
 * There is no bit for AMS_RR where all controllers support and set to 0x0 by default.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_cap_ams {
    SPDK_NVME_CAP_AMS_WRR = 1,
    SPDK_NVME_CAP_AMS_VS = 2,
}
#[repr(u32)]
/**
 * Arbitration Mechanism Selected to the controller.
 *
 * Value 0x2 to 0x6 is reserved.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_cc_ams {
    SPDK_NVME_CC_AMS_RR = 0,
    SPDK_NVME_CC_AMS_WRR = 1,
    SPDK_NVME_CC_AMS_VS = 7,
}
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_cmd {
    pub _bitfield_1: [u8; 2usize],
    pub cid: u16,
    pub nsid: u32,
    pub rsvd2: u32,
    pub rsvd3: u32,
    pub mptr: u64,
    pub dptr: spdk_nvme_cmd__bindgen_ty_1,
    pub cdw10: u32,
    pub cdw11: u32,
    pub cdw12: u32,
    pub cdw13: u32,
    pub cdw14: u32,
    pub cdw15: u32,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cmd__bindgen_ty_1 {
    pub prp: spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1,
    pub sgl1: spdk_nvme_sgl_descriptor,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub prp1: u64,
    pub prp2: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) )
                . prp1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( prp1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) )
                . prp2 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( prp2 ) ));
}
impl Clone for spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd__bindgen_ty_1 ) ) . prp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1 ) , "::" , stringify ! ( prp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd__bindgen_ty_1 ) ) . sgl1 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1 ) , "::" , stringify ! ( sgl1 )
                ));
}
impl Clone for spdk_nvme_cmd__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cmd__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmd>() , 64usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cmd ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cid as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . nsid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( nsid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . rsvd2 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( rsvd2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . rsvd3 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( rsvd3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . mptr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( mptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . dptr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( dptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw10 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw11 as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw12 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw13 as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw14 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw15 as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw15 ) ));
}
impl Clone for spdk_nvme_cmd {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cmd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl spdk_nvme_cmd {
    #[inline]
    pub fn opc(&self) -> u16 {
        let mask = 255usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: u16) {
        let mask = 255usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn fuse(&self) -> u16 {
        let mask = 768usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_fuse(&mut self, val: u16) {
        let mask = 768usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn rsvd1(&self) -> u16 {
        let mask = 15360usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u16) {
        let mask = 15360usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 10usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn psdt(&self) -> u16 {
        let mask = 49152usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_psdt(&mut self, val: u16) {
        let mask = 49152usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 14usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_status {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_status() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_status>() , 2usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_status ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_status>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( spdk_nvme_status ) ));
}
impl Clone for spdk_nvme_status {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_status {
    #[inline]
    pub fn p(&self) -> u16 {
        let mask = 1usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        let mask = 1usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn sc(&self) -> u16 {
        let mask = 510usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_sc(&mut self, val: u16) {
        let mask = 510usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn sct(&self) -> u16 {
        let mask = 3584usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_sct(&mut self, val: u16) {
        let mask = 3584usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 9usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn rsvd2(&self) -> u16 {
        let mask = 12288usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u16) {
        let mask = 12288usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 12usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn m(&self) -> u16 {
        let mask = 16384usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_m(&mut self, val: u16) {
        let mask = 16384usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 14usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn dnr(&self) -> u16 {
        let mask = 32768usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_dnr(&mut self, val: u16) {
        let mask = 32768usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 15usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/**
 * Completion queue entry
 */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cpl {
    pub cdw0: u32,
    pub rsvd1: u32,
    pub sqhd: u16,
    pub sqid: u16,
    pub cid: u16,
    pub status: spdk_nvme_status,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cpl() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cpl>() , 16usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cpl ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cpl>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cpl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . cdw0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( cdw0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . rsvd1 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( rsvd1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . sqhd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( sqhd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . sqid as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( sqid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . cid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( cid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . status as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( status ) ));
}
impl Clone for spdk_nvme_cpl {
    fn clone(&self) -> Self { *self }
}
/**
 * Dataset Management range
 */
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_dsm_range {
    pub attributes: spdk_nvme_dsm_range__bindgen_ty_1,
    pub length: u32,
    pub starting_lba: u64,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_dsm_range__bindgen_ty_1 {
    pub bits: spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1,
    pub raw: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn af(&self) -> u32 {
        let mask = 15usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_af(&mut self, val: u32) {
        let mask = 15usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn al(&self) -> u32 {
        let mask = 48usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_al(&mut self, val: u32) {
        let mask = 48usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        let mask = 192usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        let mask = 192usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 6usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn sr(&self) -> u32 {
        let mask = 256usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sr(&mut self, val: u32) {
        let mask = 256usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn sw(&self) -> u32 {
        let mask = 512usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sw(&mut self, val: u32) {
        let mask = 512usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 9usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn wp(&self) -> u32 {
        let mask = 1024usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_wp(&mut self, val: u32) {
        let mask = 1024usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 10usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 16775168usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 16775168usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 11usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn access_size(&self) -> u32 {
        let mask = 4278190080usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_access_size(&mut self, val: u32) {
        let mask = 4278190080usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 24usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_dsm_range__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_dsm_range__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_dsm_range__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range__bindgen_ty_1 ) ) .
                bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_dsm_range__bindgen_ty_1 ) , "::" , stringify ! (
                bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range__bindgen_ty_1 ) ) .
                raw as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_dsm_range__bindgen_ty_1 ) , "::" , stringify ! ( raw
                ) ));
}
impl Clone for spdk_nvme_dsm_range__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_dsm_range__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_dsm_range>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_dsm_range ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_dsm_range>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_dsm_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range ) ) . attributes as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_dsm_range ) ,
                "::" , stringify ! ( attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_dsm_range ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range ) ) . starting_lba as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_dsm_range ) ,
                "::" , stringify ! ( starting_lba ) ));
}
impl Clone for spdk_nvme_dsm_range {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_dsm_range {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/**
 * Status code types
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_status_code_type {
    SPDK_NVME_SCT_GENERIC = 0,
    SPDK_NVME_SCT_COMMAND_SPECIFIC = 1,
    SPDK_NVME_SCT_MEDIA_ERROR = 2,
    SPDK_NVME_SCT_VENDOR_SPECIFIC = 7,
}
#[repr(u32)]
/**
 * Generic command status codes
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_generic_command_status_code {
    SPDK_NVME_SC_SUCCESS = 0,
    SPDK_NVME_SC_INVALID_OPCODE = 1,
    SPDK_NVME_SC_INVALID_FIELD = 2,
    SPDK_NVME_SC_COMMAND_ID_CONFLICT = 3,
    SPDK_NVME_SC_DATA_TRANSFER_ERROR = 4,
    SPDK_NVME_SC_ABORTED_POWER_LOSS = 5,
    SPDK_NVME_SC_INTERNAL_DEVICE_ERROR = 6,
    SPDK_NVME_SC_ABORTED_BY_REQUEST = 7,
    SPDK_NVME_SC_ABORTED_SQ_DELETION = 8,
    SPDK_NVME_SC_ABORTED_FAILED_FUSED = 9,
    SPDK_NVME_SC_ABORTED_MISSING_FUSED = 10,
    SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT = 11,
    SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR = 12,
    SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR = 13,
    SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS = 14,
    SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID = 15,
    SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID = 16,
    SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID = 17,
    SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF = 18,
    SPDK_NVME_SC_INVALID_PRP_OFFSET = 19,
    SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED = 20,
    SPDK_NVME_SC_INVALID_SGL_OFFSET = 22,
    SPDK_NVME_SC_INVALID_SGL_SUBTYPE = 23,
    SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT = 24,
    SPDK_NVME_SC_KEEP_ALIVE_EXPIRED = 25,
    SPDK_NVME_SC_KEEP_ALIVE_INVALID = 26,
    SPDK_NVME_SC_LBA_OUT_OF_RANGE = 128,
    SPDK_NVME_SC_CAPACITY_EXCEEDED = 129,
    SPDK_NVME_SC_NAMESPACE_NOT_READY = 130,
    SPDK_NVME_SC_RESERVATION_CONFLICT = 131,
    SPDK_NVME_SC_FORMAT_IN_PROGRESS = 132,
}
#[repr(u32)]
/**
 * Command specific status codes
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_command_specific_status_code {
    SPDK_NVME_SC_COMPLETION_QUEUE_INVALID = 0,
    SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER = 1,
    SPDK_NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED = 2,
    SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED = 3,
    SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED = 5,
    SPDK_NVME_SC_INVALID_FIRMWARE_SLOT = 6,
    SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE = 7,
    SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR = 8,
    SPDK_NVME_SC_INVALID_LOG_PAGE = 9,
    SPDK_NVME_SC_INVALID_FORMAT = 10,
    SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET = 11,
    SPDK_NVME_SC_INVALID_QUEUE_DELETION = 12,
    SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE = 13,
    SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE = 14,
    SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC = 15,
    SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET = 16,
    SPDK_NVME_SC_FIRMWARE_REQ_RESET = 17,
    SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION = 18,
    SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED = 19,
    SPDK_NVME_SC_OVERLAPPING_RANGE = 20,
    SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY = 21,
    SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE = 22,
    SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED = 24,
    SPDK_NVME_SC_NAMESPACE_IS_PRIVATE = 25,
    SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED = 26,
    SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED = 27,
    SPDK_NVME_SC_CONTROLLER_LIST_INVALID = 28,
    SPDK_NVME_SC_CONFLICTING_ATTRIBUTES = 128,
    SPDK_NVME_SC_INVALID_PROTECTION_INFO = 129,
    SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE = 130,
}
#[repr(u32)]
/**
 * Media error status codes
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_media_error_status_code {
    SPDK_NVME_SC_WRITE_FAULTS = 128,
    SPDK_NVME_SC_UNRECOVERED_READ_ERROR = 129,
    SPDK_NVME_SC_GUARD_CHECK_ERROR = 130,
    SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR = 131,
    SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR = 132,
    SPDK_NVME_SC_COMPARE_FAILURE = 133,
    SPDK_NVME_SC_ACCESS_DENIED = 134,
    SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK = 135,
}
#[repr(u32)]
/**
 * Admin opcodes
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_admin_opcode {
    SPDK_NVME_OPC_DELETE_IO_SQ = 0,
    SPDK_NVME_OPC_CREATE_IO_SQ = 1,
    SPDK_NVME_OPC_GET_LOG_PAGE = 2,
    SPDK_NVME_OPC_DELETE_IO_CQ = 4,
    SPDK_NVME_OPC_CREATE_IO_CQ = 5,
    SPDK_NVME_OPC_IDENTIFY = 6,
    SPDK_NVME_OPC_ABORT = 8,
    SPDK_NVME_OPC_SET_FEATURES = 9,
    SPDK_NVME_OPC_GET_FEATURES = 10,
    SPDK_NVME_OPC_ASYNC_EVENT_REQUEST = 12,
    SPDK_NVME_OPC_NS_MANAGEMENT = 13,
    SPDK_NVME_OPC_FIRMWARE_COMMIT = 16,
    SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD = 17,
    SPDK_NVME_OPC_NS_ATTACHMENT = 21,
    SPDK_NVME_OPC_KEEP_ALIVE = 24,
    SPDK_NVME_OPC_FORMAT_NVM = 128,
    SPDK_NVME_OPC_SECURITY_SEND = 129,
    SPDK_NVME_OPC_SECURITY_RECEIVE = 130,
}
#[repr(u32)]
/**
 * NVM command set opcodes
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_nvm_opcode {
    SPDK_NVME_OPC_FLUSH = 0,
    SPDK_NVME_OPC_WRITE = 1,
    SPDK_NVME_OPC_READ = 2,
    SPDK_NVME_OPC_WRITE_UNCORRECTABLE = 4,
    SPDK_NVME_OPC_COMPARE = 5,
    SPDK_NVME_OPC_WRITE_ZEROES = 8,
    SPDK_NVME_OPC_DATASET_MANAGEMENT = 9,
    SPDK_NVME_OPC_RESERVATION_REGISTER = 13,
    SPDK_NVME_OPC_RESERVATION_REPORT = 14,
    SPDK_NVME_OPC_RESERVATION_ACQUIRE = 17,
    SPDK_NVME_OPC_RESERVATION_RELEASE = 21,
}
#[repr(u32)]
/**
 * Data transfer (bits 1:0) of an NVMe opcode.
 *
 * \sa spdk_nvme_opc_get_data_transfer
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_data_transfer {
    SPDK_NVME_DATA_NONE = 0,
    SPDK_NVME_DATA_HOST_TO_CONTROLLER = 1,
    SPDK_NVME_DATA_CONTROLLER_TO_HOST = 2,
    SPDK_NVME_DATA_BIDIRECTIONAL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_feat {
    SPDK_NVME_FEAT_ARBITRATION = 1,
    SPDK_NVME_FEAT_POWER_MANAGEMENT = 2,
    SPDK_NVME_FEAT_LBA_RANGE_TYPE = 3,
    SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD = 4,
    SPDK_NVME_FEAT_ERROR_RECOVERY = 5,
    SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE = 6,
    SPDK_NVME_FEAT_NUMBER_OF_QUEUES = 7,
    SPDK_NVME_FEAT_INTERRUPT_COALESCING = 8,
    SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION = 9,
    SPDK_NVME_FEAT_WRITE_ATOMICITY = 10,
    SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION = 11,
    SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION = 12,
    SPDK_NVME_FEAT_HOST_MEM_BUFFER = 13,
    SPDK_NVME_FEAT_KEEP_ALIVE_TIMER = 15,
    SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER = 128,
    SPDK_NVME_FEAT_HOST_IDENTIFIER = 129,
    SPDK_NVME_FEAT_HOST_RESERVE_MASK = 130,
    SPDK_NVME_FEAT_HOST_RESERVE_PERSIST = 131,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_dsm_attribute {
    SPDK_NVME_DSM_ATTR_INTEGRAL_READ = 1,
    SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE = 2,
    SPDK_NVME_DSM_ATTR_DEALLOCATE = 4,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_power_state {
    pub mp: u16,
    pub reserved1: u8,
    pub _bitfield_1: u8,
    pub enlat: u32,
    pub exlat: u32,
    pub _bitfield_2: u8,
    pub _bitfield_3: u8,
    pub _bitfield_4: u8,
    pub _bitfield_5: u8,
    pub reserved7: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_power_state() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_power_state>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_power_state )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_power_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_power_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . mp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( mp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . reserved1 as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . enlat as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( enlat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . exlat as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( exlat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . reserved7 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( reserved7 ) ));
}
impl Clone for spdk_nvme_power_state {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_power_state {
    #[inline]
    pub fn mps(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn nops(&self) -> u8 {
        let mask = 2usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_nops(&mut self, val: u8) {
        let mask = 2usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        let mask = 252usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        let mask = 252usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn rrt(&self) -> u8 {
        let mask = 31usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rrt(&mut self, val: u8) {
        let mask = 31usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        let mask = 224usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        let mask = 224usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn rrl(&self) -> u8 {
        let mask = 31usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_3) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rrl(&mut self, val: u8) {
        let mask = 31usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_3) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_3 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved4(&self) -> u8 {
        let mask = 224usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_3) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u8) {
        let mask = 224usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_3) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_3 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn rwt(&self) -> u8 {
        let mask = 31usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_4) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rwt(&mut self, val: u8) {
        let mask = 31usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_4) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_4 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved5(&self) -> u8 {
        let mask = 224usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_4) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u8) {
        let mask = 224usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_4) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_4 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn rwl(&self) -> u8 {
        let mask = 31usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_5) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rwl(&mut self, val: u8) {
        let mask = 31usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_5) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_5 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved6(&self) -> u8 {
        let mask = 224usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_5) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u8) {
        let mask = 224usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_5) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_5 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[repr(u32)]
/** Identify command CNS value */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_identify_cns {
    SPDK_NVME_IDENTIFY_NS = 0,
    SPDK_NVME_IDENTIFY_CTRLR = 1,
    SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST = 2,
    SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST = 16,
    SPDK_NVME_IDENTIFY_NS_ALLOCATED = 17,
    SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST = 18,
    SPDK_NVME_IDENTIFY_CTRLR_LIST = 19,
}
#[repr(C, packed)]
pub struct spdk_nvme_ctrlr_data {
    /** pci vendor id */
    pub vid: u16,
    /** pci subsystem vendor id */
    pub ssvid: u16,
    /** serial number */
    pub sn: [i8; 20usize],
    /** model number */
    pub mn: [i8; 40usize],
    /** firmware revision */
    pub fr: [u8; 8usize],
    /** recommended arbitration burst */
    pub rab: u8,
    /** ieee oui identifier */
    pub ieee: [u8; 3usize],
    pub cmic: spdk_nvme_ctrlr_data__bindgen_ty_1,
    /** maximum data transfer size */
    pub mdts: u8,
    /** controller id */
    pub cntlid: u16,
    /** version */
    pub ver: spdk_nvme_vs_register,
    /** RTD3 resume latency */
    pub rtd3r: u32,
    /** RTD3 entry latency */
    pub rtd3e: u32,
    pub oaes: spdk_nvme_ctrlr_data__bindgen_ty_2,
    pub ctratt: spdk_nvme_ctrlr_data__bindgen_ty_3,
    pub reserved1: [u8; 156usize],
    pub oacs: spdk_nvme_ctrlr_data__bindgen_ty_4,
    /** abort command limit */
    pub acl: u8,
    /** asynchronous event request limit */
    pub aerl: u8,
    pub frmw: spdk_nvme_ctrlr_data__bindgen_ty_5,
    pub lpa: spdk_nvme_ctrlr_data__bindgen_ty_6,
    /** error log page entries */
    pub elpe: u8,
    /** number of power states supported */
    pub npss: u8,
    pub avscc: spdk_nvme_ctrlr_data__bindgen_ty_7,
    pub apsta: spdk_nvme_ctrlr_data__bindgen_ty_8,
    /** warning composite temperature threshold */
    pub wctemp: u16,
    /** critical composite temperature threshold */
    pub cctemp: u16,
    /** maximum time for firmware activation */
    pub mtfa: u16,
    /** host memory buffer preferred size */
    pub hmpre: u32,
    /** host memory buffer minimum size */
    pub hmmin: u32,
    /** total NVM capacity */
    pub tnvmcap: [u64; 2usize],
    /** unallocated NVM capacity */
    pub unvmcap: [u64; 2usize],
    pub rpmbs: spdk_nvme_ctrlr_data__bindgen_ty_9,
    pub reserved2: [u8; 4usize],
    pub kas: u16,
    pub reserved3: [u8; 190usize],
    pub sqes: spdk_nvme_ctrlr_data__bindgen_ty_10,
    pub cqes: spdk_nvme_ctrlr_data__bindgen_ty_11,
    pub maxcmd: u16,
    /** number of namespaces */
    pub nn: u32,
    pub oncs: spdk_nvme_ctrlr_data__bindgen_ty_12,
    /** fused operation support */
    pub fuses: u16,
    pub fna: spdk_nvme_ctrlr_data__bindgen_ty_13,
    pub vwc: spdk_nvme_ctrlr_data__bindgen_ty_14,
    /** atomic write unit normal */
    pub awun: u16,
    /** atomic write unit power fail */
    pub awupf: u16,
    /** NVM vendor specific command configuration */
    pub nvscc: u8,
    pub reserved531: u8,
    /** atomic compare & write unit */
    pub acwu: u16,
    pub reserved534: u16,
    pub sgls: spdk_nvme_ctrlr_data__bindgen_ty_15,
    pub reserved4: [u8; 228usize],
    pub subnqn: [u8; 256usize],
    pub reserved5: [u8; 768usize],
    pub nvmf_specific: spdk_nvme_ctrlr_data__bindgen_ty_16,
    pub psd: [spdk_nvme_power_state; 32usize],
    pub vs: [u8; 1024usize],
}
/** controller multi-path I/O and namespace sharing capabilities */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_1>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_1 {
    #[inline]
    pub fn multi_port(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_multi_port(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn multi_host(&self) -> u8 {
        let mask = 2usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_multi_host(&mut self, val: u8) {
        let mask = 2usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn sr_iov(&self) -> u8 {
        let mask = 4usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_sr_iov(&mut self, val: u8) {
        let mask = 4usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mask = 248usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 248usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** optional asynchronous events supported */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_2 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_2>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_2 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_2 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 255usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 255usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn ns_attribute_notices(&self) -> u32 {
        let mask = 256usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ns_attribute_notices(&mut self, val: u32) {
        let mask = 256usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn fw_activation_notices(&self) -> u32 {
        let mask = 512usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_fw_activation_notices(&mut self, val: u32) {
        let mask = 512usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 9usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mask = 4294966272usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 4294966272usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 10usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** controller attributes */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_3 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_3>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_3
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_3>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_3 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_3 {
    #[inline]
    pub fn host_id_exhid_supported(&self) -> u32 {
        let mask = 1usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_host_id_exhid_supported(&mut self, val: u32) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mask = 4294967294usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967294usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** optional admin command support */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_4 {
    pub _bitfield_1: u16,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_4>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_4
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_4>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_4 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_4 {
    #[inline]
    pub fn security(&self) -> u16 {
        let mask = 1usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_security(&mut self, val: u16) {
        let mask = 1usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn format(&self) -> u16 {
        let mask = 2usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_format(&mut self, val: u16) {
        let mask = 2usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn firmware(&self) -> u16 {
        let mask = 4usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_firmware(&mut self, val: u16) {
        let mask = 4usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn ns_manage(&self) -> u16 {
        let mask = 8usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_ns_manage(&mut self, val: u16) {
        let mask = 8usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn oacs_rsvd(&self) -> u16 {
        let mask = 65520usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_oacs_rsvd(&mut self, val: u16) {
        let mask = 65520usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** firmware updates */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_5 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_5>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_5
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_5>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_5 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_5 {
    #[inline]
    pub fn slot1_ro(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_slot1_ro(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn num_slots(&self) -> u8 {
        let mask = 14usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_num_slots(&mut self, val: u8) {
        let mask = 14usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn activation_without_reset(&self) -> u8 {
        let mask = 16usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_activation_without_reset(&mut self, val: u8) {
        let mask = 16usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn frmw_rsvd(&self) -> u8 {
        let mask = 224usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_frmw_rsvd(&mut self, val: u8) {
        let mask = 224usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** log page attributes */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_6 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_6>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_6
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_6>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_6 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_6 {
    #[inline]
    pub fn ns_smart(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ns_smart(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn celp(&self) -> u8 {
        let mask = 2usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_celp(&mut self, val: u8) {
        let mask = 2usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn edlp(&self) -> u8 {
        let mask = 4usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_edlp(&mut self, val: u8) {
        let mask = 4usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn lpa_rsvd(&self) -> u8 {
        let mask = 248usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_lpa_rsvd(&mut self, val: u8) {
        let mask = 248usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** admin vendor specific command configuration */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_7 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_7>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_7
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_7>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_7 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_7 {
    #[inline]
    pub fn spec_format(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_spec_format(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn avscc_rsvd(&self) -> u8 {
        let mask = 254usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_avscc_rsvd(&mut self, val: u8) {
        let mask = 254usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** autonomous power state transition attributes */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_8 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_8>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_8
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_8>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_8 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_8 {
    #[inline]
    pub fn supported(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn apsta_rsvd(&self) -> u8 {
        let mask = 254usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_apsta_rsvd(&mut self, val: u8) {
        let mask = 254usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** replay protected memory block support */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_9 {
    pub _bitfield_1: u8,
    pub reserved2: u8,
    pub total_size: u8,
    pub access_size: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_9>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_9
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_9>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) .
                reserved2 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_9 ) , "::" , stringify ! (
                reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) .
                total_size as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_9 ) , "::" , stringify ! (
                total_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) .
                access_size as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_9 ) , "::" , stringify ! (
                access_size ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_9 {
    #[inline]
    pub fn num_rpmb_units(&self) -> u8 {
        let mask = 7usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_num_rpmb_units(&mut self, val: u8) {
        let mask = 7usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn auth_method(&self) -> u8 {
        let mask = 56usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_auth_method(&mut self, val: u8) {
        let mask = 56usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        let mask = 192usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        let mask = 192usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 6usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** submission queue entry size */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_10 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_10>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_10>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_10 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_10 {
    #[inline]
    pub fn min(&self) -> u8 {
        let mask = 15usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_min(&mut self, val: u8) {
        let mask = 15usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn max(&self) -> u8 {
        let mask = 240usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u8) {
        let mask = 240usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** completion queue entry size */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_11 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_11>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_11>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_11 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_11 {
    #[inline]
    pub fn min(&self) -> u8 {
        let mask = 15usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_min(&mut self, val: u8) {
        let mask = 15usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn max(&self) -> u8 {
        let mask = 240usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u8) {
        let mask = 240usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** optional nvm command support */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_12 {
    pub _bitfield_1: u16,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_12>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_12>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_12 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_12 {
    #[inline]
    pub fn compare(&self) -> u16 {
        let mask = 1usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_compare(&mut self, val: u16) {
        let mask = 1usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn write_unc(&self) -> u16 {
        let mask = 2usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_write_unc(&mut self, val: u16) {
        let mask = 2usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn dsm(&self) -> u16 {
        let mask = 4usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_dsm(&mut self, val: u16) {
        let mask = 4usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn write_zeroes(&self) -> u16 {
        let mask = 8usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_write_zeroes(&mut self, val: u16) {
        let mask = 8usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn set_features_save(&self) -> u16 {
        let mask = 16usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_set_features_save(&mut self, val: u16) {
        let mask = 16usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reservations(&self) -> u16 {
        let mask = 32usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_reservations(&mut self, val: u16) {
        let mask = 32usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        let mask = 65472usize as u16;
        let field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        let mask = 65472usize as u16;
        let val = val as u16 as u16;
        let mut field_val: u16 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 6usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** format nvm attributes */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_13 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_13>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_13
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_13>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_13 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_13 {
    #[inline]
    pub fn format_all_ns(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_format_all_ns(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn erase_all_ns(&self) -> u8 {
        let mask = 2usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_erase_all_ns(&mut self, val: u8) {
        let mask = 2usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn crypto_erase_supported(&self) -> u8 {
        let mask = 4usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_crypto_erase_supported(&mut self, val: u8) {
        let mask = 4usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mask = 248usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 248usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** volatile write cache */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_14 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_14>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_14
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_14>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_14 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_14 {
    #[inline]
    pub fn present(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_present(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mask = 254usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 254usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** SGL support */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_15 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_15>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_15
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_15>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_15 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_15 {
    #[inline]
    pub fn supported(&self) -> u32 {
        let mask = 1usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u32) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        let mask = 2usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn keyed_sgl(&self) -> u32 {
        let mask = 4usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_keyed_sgl(&mut self, val: u32) {
        let mask = 4usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mask = 65528usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 65528usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn bit_bucket_descriptor(&self) -> u32 {
        let mask = 65536usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bit_bucket_descriptor(&mut self, val: u32) {
        let mask = 65536usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn metadata_pointer(&self) -> u32 {
        let mask = 131072usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_metadata_pointer(&mut self, val: u32) {
        let mask = 131072usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 17usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn oversized_sgl(&self) -> u32 {
        let mask = 262144usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_oversized_sgl(&mut self, val: u32) {
        let mask = 262144usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 18usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn metadata_address(&self) -> u32 {
        let mask = 524288usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_metadata_address(&mut self, val: u32) {
        let mask = 524288usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 19usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn sgl_offset(&self) -> u32 {
        let mask = 1048576usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sgl_offset(&mut self, val: u32) {
        let mask = 1048576usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 20usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mask = 4292870144usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 21usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 4292870144usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 21usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** NVMe over Fabrics-specific fields */
#[repr(C)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_16 {
    /** I/O queue command capsule supported size (16-byte units) */
    pub ioccsz: u32,
    /** I/O queue response capsule supported size (16-byte units) */
    pub iorcsz: u32,
    /** In-capsule data offset (16-byte units) */
    pub icdoff: u16,
    pub ctrattr: spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1,
    /** Maximum SGL block descriptors (0 = no limit) */
    pub msdbd: u8,
    pub reserved: [u8; 244usize],
}
/** Controller attributes */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn ctrlr_model(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ctrlr_model(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mask = 254usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 254usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_16>() ,
               256usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_16
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_16>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) .
                ioccsz as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16 ) , "::" , stringify ! (
                ioccsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) .
                iorcsz as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16 ) , "::" , stringify ! (
                iorcsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) .
                icdoff as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16 ) , "::" , stringify ! (
                icdoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) .
                ctrattr as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16 ) , "::" , stringify ! (
                ctrattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) .
                msdbd as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16 ) , "::" , stringify ! (
                msdbd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) .
                reserved as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16 ) , "::" , stringify ! (
                reserved ) ));
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_16 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data>() , 4096usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . vid as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( vid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . ssvid as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( ssvid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . sn as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( sn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . mn as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( mn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . fr as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( fr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . rab as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( rab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . ieee as *
                const _ as usize } , 73usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( ieee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . cmic as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( cmic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . mdts as *
                const _ as usize } , 77usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( mdts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . cntlid as *
                const _ as usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( cntlid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . ver as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . rtd3r as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( rtd3r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . rtd3e as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( rtd3e ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . oaes as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( oaes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . ctratt as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( ctratt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved1 as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . oacs as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( oacs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . acl as * const
                _ as usize } , 258usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( acl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . aerl as *
                const _ as usize } , 259usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( aerl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . frmw as *
                const _ as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( frmw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . lpa as * const
                _ as usize } , 261usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( lpa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . elpe as *
                const _ as usize } , 262usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( elpe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . npss as *
                const _ as usize } , 263usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( npss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . avscc as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( avscc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . apsta as *
                const _ as usize } , 265usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( apsta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . wctemp as *
                const _ as usize } , 266usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( wctemp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . cctemp as *
                const _ as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( cctemp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . mtfa as *
                const _ as usize } , 270usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( mtfa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . hmpre as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( hmpre ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . hmmin as *
                const _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( hmmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . tnvmcap as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( tnvmcap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . unvmcap as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( unvmcap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . rpmbs as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( rpmbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved2 as *
                const _ as usize } , 316usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . kas as * const
                _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( kas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved3 as *
                const _ as usize } , 322usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . sqes as *
                const _ as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( sqes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . cqes as *
                const _ as usize } , 513usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( cqes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . maxcmd as *
                const _ as usize } , 514usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( maxcmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . nn as * const
                _ as usize } , 516usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( nn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . oncs as *
                const _ as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( oncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . fuses as *
                const _ as usize } , 522usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( fuses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . fna as * const
                _ as usize } , 524usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( fna ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . vwc as * const
                _ as usize } , 525usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( vwc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . awun as *
                const _ as usize } , 526usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( awun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . awupf as *
                const _ as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( awupf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . nvscc as *
                const _ as usize } , 530usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( nvscc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved531 as
                * const _ as usize } , 531usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved531 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . acwu as *
                const _ as usize } , 532usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( acwu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved534 as
                * const _ as usize } , 534usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved534 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . sgls as *
                const _ as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( sgls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved4 as *
                const _ as usize } , 540usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . subnqn as *
                const _ as usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( subnqn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved5 as *
                const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . nvmf_specific
                as * const _ as usize } , 1792usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( nvmf_specific ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . psd as * const
                _ as usize } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( psd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . vs as * const
                _ as usize } , 3072usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( vs ) ));
}
impl Default for spdk_nvme_ctrlr_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct spdk_nvme_ns_data {
    /** namespace size */
    pub nsze: u64,
    /** namespace capacity */
    pub ncap: u64,
    /** namespace utilization */
    pub nuse: u64,
    pub nsfeat: spdk_nvme_ns_data__bindgen_ty_1,
    /** number of lba formats */
    pub nlbaf: u8,
    pub flbas: spdk_nvme_ns_data__bindgen_ty_2,
    pub mc: spdk_nvme_ns_data__bindgen_ty_3,
    pub dpc: spdk_nvme_ns_data__bindgen_ty_4,
    pub dps: spdk_nvme_ns_data__bindgen_ty_5,
    pub nmic: spdk_nvme_ns_data__bindgen_ty_6,
    pub nsrescap: spdk_nvme_ns_data__bindgen_ty_7,
    pub fpi: spdk_nvme_ns_data__bindgen_ty_8,
    pub reserved33: u8,
    /** namespace atomic write unit normal */
    pub nawun: u16,
    /** namespace atomic write unit power fail */
    pub nawupf: u16,
    /** namespace atomic compare & write unit */
    pub nacwu: u16,
    /** namespace atomic boundary size normal */
    pub nabsn: u16,
    /** namespace atomic boundary offset */
    pub nabo: u16,
    /** namespace atomic boundary size power fail */
    pub nabspf: u16,
    pub reserved46: u16,
    /** NVM capacity */
    pub nvmcap: [u64; 2usize],
    pub reserved64: [u8; 40usize],
    /** namespace globally unique identifier */
    pub nguid: [u8; 16usize],
    /** IEEE extended unique identifier */
    pub eui64: u64,
    pub lbaf: [spdk_nvme_ns_data__bindgen_ty_9; 16usize],
    pub reserved6: [u8; 192usize],
    pub vendor_specific: [u8; 3712usize],
}
/** namespace features */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_1>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_1 {
    #[inline]
    pub fn thin_prov(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_thin_prov(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        let mask = 254usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        let mask = 254usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** formatted lba size */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_2 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_2>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_2>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_2 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_2 {
    #[inline]
    pub fn format(&self) -> u8 {
        let mask = 15usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_format(&mut self, val: u8) {
        let mask = 15usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn extended(&self) -> u8 {
        let mask = 16usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        let mask = 16usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        let mask = 224usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        let mask = 224usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** metadata capabilities */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_3 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_3>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_3 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_3>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_3 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_3 {
    #[inline]
    pub fn extended(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn pointer(&self) -> u8 {
        let mask = 2usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pointer(&mut self, val: u8) {
        let mask = 2usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        let mask = 252usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        let mask = 252usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** end-to-end data protection capabilities */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_4 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_4>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_4 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_4>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_4 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_4 {
    #[inline]
    pub fn pit1(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pit1(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn pit2(&self) -> u8 {
        let mask = 2usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pit2(&mut self, val: u8) {
        let mask = 2usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn pit3(&self) -> u8 {
        let mask = 4usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pit3(&mut self, val: u8) {
        let mask = 4usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn md_start(&self) -> u8 {
        let mask = 8usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_md_start(&mut self, val: u8) {
        let mask = 8usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn md_end(&self) -> u8 {
        let mask = 16usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_md_end(&mut self, val: u8) {
        let mask = 16usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** end-to-end data protection type settings */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_5 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_5>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_5 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_5>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_5 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_5 {
    #[inline]
    pub fn pit(&self) -> u8 {
        let mask = 7usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pit(&mut self, val: u8) {
        let mask = 7usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn md_start(&self) -> u8 {
        let mask = 8usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_md_start(&mut self, val: u8) {
        let mask = 8usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved4(&self) -> u8 {
        let mask = 240usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u8) {
        let mask = 240usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** namespace multi-path I/O and namespace sharing capabilities */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_6 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_6>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_6 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_6>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_6 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_6 {
    #[inline]
    pub fn can_share(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_can_share(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mask = 254usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 254usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** reservation capabilities */
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_ns_data__bindgen_ty_7 {
    pub rescap: spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1,
    pub raw: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn persist(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_persist(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn write_exclusive(&self) -> u8 {
        let mask = 2usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_write_exclusive(&mut self, val: u8) {
        let mask = 2usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn exclusive_access(&self) -> u8 {
        let mask = 4usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_exclusive_access(&mut self, val: u8) {
        let mask = 4usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn write_exclusive_reg_only(&self) -> u8 {
        let mask = 8usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_write_exclusive_reg_only(&mut self, val: u8) {
        let mask = 8usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn exclusive_access_reg_only(&self) -> u8 {
        let mask = 16usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_exclusive_access_reg_only(&mut self, val: u8) {
        let mask = 16usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn write_exclusive_all_reg(&self) -> u8 {
        let mask = 32usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_write_exclusive_all_reg(&mut self, val: u8) {
        let mask = 32usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn exclusive_access_all_reg(&self) -> u8 {
        let mask = 64usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_exclusive_access_all_reg(&mut self, val: u8) {
        let mask = 64usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 6usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mask = 128usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 128usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 7usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_7>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_7>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data__bindgen_ty_7 ) ) .
                rescap as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_7 ) , "::" , stringify ! (
                rescap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data__bindgen_ty_7 ) ) . raw
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_7 ) , "::" , stringify ! ( raw )
                ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ns_data__bindgen_ty_7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/** format progress indicator */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_8 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_8>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_8 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_8>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_8 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_8 {
    #[inline]
    pub fn percentage_remaining(&self) -> u8 {
        let mask = 127usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_percentage_remaining(&mut self, val: u8) {
        let mask = 127usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn fpi_supported(&self) -> u8 {
        let mask = 128usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_fpi_supported(&mut self, val: u8) {
        let mask = 128usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 7usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
/** lba format support */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_9 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_9>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_9>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_9 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_9 {
    #[inline]
    pub fn ms(&self) -> u32 {
        let mask = 65535usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ms(&mut self, val: u32) {
        let mask = 65535usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn lbads(&self) -> u32 {
        let mask = 16711680usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lbads(&mut self, val: u32) {
        let mask = 16711680usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn rp(&self) -> u32 {
        let mask = 50331648usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rp(&mut self, val: u32) {
        let mask = 50331648usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 24usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        let mask = 4227858432usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        let mask = 4227858432usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 26usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data>() , 4096usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nsze as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nsze ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . ncap as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( ncap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nuse as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nuse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nsfeat as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nsfeat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nlbaf as * const
                _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nlbaf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . flbas as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( flbas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . mc as * const _
                as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( mc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . dpc as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( dpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . dps as * const _
                as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( dps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nmic as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nmic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nsrescap as *
                const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nsrescap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . fpi as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( fpi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . reserved33 as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( reserved33 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nawun as * const
                _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nawun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nawupf as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nawupf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nacwu as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nacwu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nabsn as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nabsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nabo as * const _
                as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nabo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nabspf as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nabspf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . reserved46 as *
                const _ as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( reserved46 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nvmcap as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nvmcap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . reserved64 as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( reserved64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nguid as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nguid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . eui64 as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( eui64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . lbaf as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( lbaf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . reserved6 as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . vendor_specific
                as * const _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( vendor_specific ) ));
}
impl Default for spdk_nvme_ns_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/**
 * Reservation Type Encoding
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_type {
    SPDK_NVME_RESERVE_WRITE_EXCLUSIVE = 1,
    SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS = 2,
    SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY = 3,
    SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY = 4,
    SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS = 5,
    SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS = 6,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_acquire_data {
    /** current reservation key */
    pub crkey: u64,
    /** preempt reservation key */
    pub prkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_acquire_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_acquire_data>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_acquire_data
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_acquire_data>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_acquire_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_acquire_data ) ) .
                crkey as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_acquire_data ) , "::" , stringify ! (
                crkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_acquire_data ) ) .
                prkey as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_acquire_data ) , "::" , stringify ! (
                prkey ) ));
}
impl Clone for spdk_nvme_reservation_acquire_data {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Reservation Acquire action
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_acquire_action {
    SPDK_NVME_RESERVE_ACQUIRE = 0,
    SPDK_NVME_RESERVE_PREEMPT = 1,
    SPDK_NVME_RESERVE_PREEMPT_ABORT = 2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_status_data {
    /** reservation action generation counter */
    pub generation: u32,
    /** reservation type */
    pub type_: u8,
    /** number of registered controllers */
    pub nr_regctl: u16,
    pub reserved1: u16,
    /** persist through power loss state */
    pub ptpl_state: u8,
    pub reserved: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_status_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_status_data>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_status_data )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_status_data>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_status_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                generation as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                generation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                type_ as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                nr_regctl as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                nr_regctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                reserved1 as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                ptpl_state as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                ptpl_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                reserved as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for spdk_nvme_reservation_status_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_ctrlr_data {
    pub ctrlr_id: u16,
    pub rcsts: spdk_nvme_reservation_ctrlr_data__bindgen_ty_1,
    pub reserved2: [u8; 5usize],
    /** host identifier */
    pub host_id: u64,
    /** reservation key */
    pub key: u64,
}
/** reservation status */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_ctrlr_data__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_ctrlr_data__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        let mask = 254usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        let mask = 254usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_ctrlr_data>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_ctrlr_data )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_ctrlr_data>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                ctrlr_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! (
                ctrlr_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                rcsts as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! (
                rcsts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                reserved2 as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! (
                reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                host_id as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! (
                host_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                key as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! ( key
                ) ));
}
impl Clone for spdk_nvme_reservation_ctrlr_data {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Change persist through power loss state for
 *  Reservation Register command
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_register_cptpl {
    SPDK_NVME_RESERVE_PTPL_NO_CHANGES = 0,
    SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON = 2,
    SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS = 3,
}
#[repr(u32)]
/**
 * Registration action for Reservation Register command
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_register_action {
    SPDK_NVME_RESERVE_REGISTER_KEY = 0,
    SPDK_NVME_RESERVE_UNREGISTER_KEY = 1,
    SPDK_NVME_RESERVE_REPLACE_KEY = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_register_data {
    /** current reservation key */
    pub crkey: u64,
    /** new reservation key */
    pub nrkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_register_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_register_data>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_register_data
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_register_data>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_register_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_register_data ) ) .
                crkey as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_register_data ) , "::" , stringify ! (
                crkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_register_data ) ) .
                nrkey as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_register_data ) , "::" , stringify ! (
                nrkey ) ));
}
impl Clone for spdk_nvme_reservation_register_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_key_data {
    /** current reservation key */
    pub crkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_key_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_key_data>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_key_data )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_key_data>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_reservation_key_data
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_key_data ) ) .
                crkey as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_key_data ) , "::" , stringify ! ( crkey
                ) ));
}
impl Clone for spdk_nvme_reservation_key_data {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Reservation Release action
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_release_action {
    SPDK_NVME_RESERVE_RELEASE = 0,
    SPDK_NVME_RESERVE_CLEAR = 1,
}
#[repr(u32)]
/**
 * Log page identifiers for SPDK_NVME_OPC_GET_LOG_PAGE
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_log_page {
    SPDK_NVME_LOG_ERROR = 1,
    SPDK_NVME_LOG_HEALTH_INFORMATION = 2,
    SPDK_NVME_LOG_FIRMWARE_SLOT = 3,
    SPDK_NVME_LOG_CHANGED_NS_LIST = 4,
    SPDK_NVME_LOG_COMMAND_EFFECTS_LOG = 5,
    SPDK_NVME_LOG_DISCOVERY = 112,
    SPDK_NVME_LOG_RESERVATION_NOTIFICATION = 128,
}
/**
 * Error information log page (\ref SPDK_NVME_LOG_ERROR)
 */
#[repr(C)]
pub struct spdk_nvme_error_information_entry {
    pub error_count: u64,
    pub sqid: u16,
    pub cid: u16,
    pub status: spdk_nvme_status,
    pub error_location: u16,
    pub lba: u64,
    pub nsid: u32,
    pub vendor_specific: u8,
    pub reserved: [u8; 35usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_error_information_entry() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_error_information_entry>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_error_information_entry )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_error_information_entry>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_error_information_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                error_count as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                error_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                sqid as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                sqid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                cid as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! ( cid
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                status as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                error_location as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                error_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                lba as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! ( lba
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                nsid as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                nsid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                vendor_specific as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                vendor_specific ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                reserved as * const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                reserved ) ));
}
impl Default for spdk_nvme_error_information_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_critical_warning_state {
    pub raw: u8,
    pub bits: spdk_nvme_critical_warning_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_critical_warning_state__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_critical_warning_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_critical_warning_state__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_critical_warning_state__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_critical_warning_state__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_critical_warning_state__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_critical_warning_state__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_critical_warning_state__bindgen_ty_1 {
    #[inline]
    pub fn available_spare(&self) -> u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_available_spare(&mut self, val: u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn temperature(&self) -> u8 {
        let mask = 2usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_temperature(&mut self, val: u8) {
        let mask = 2usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn device_reliability(&self) -> u8 {
        let mask = 4usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_device_reliability(&mut self, val: u8) {
        let mask = 4usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn read_only(&self) -> u8 {
        let mask = 8usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_read_only(&mut self, val: u8) {
        let mask = 8usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn volatile_memory_backup(&self) -> u8 {
        let mask = 16usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_volatile_memory_backup(&mut self, val: u8) {
        let mask = 16usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mask = 224usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 224usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_critical_warning_state() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_critical_warning_state>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_critical_warning_state )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_critical_warning_state>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_critical_warning_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_critical_warning_state ) ) .
                raw as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_critical_warning_state ) , "::" , stringify ! ( raw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_critical_warning_state ) ) .
                bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_critical_warning_state ) , "::" , stringify ! ( bits
                ) ));
}
impl Clone for spdk_nvme_critical_warning_state {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_critical_warning_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/**
 * SMART / health information page (\ref SPDK_NVME_LOG_HEALTH_INFORMATION)
 */
#[repr(C, packed)]
pub struct spdk_nvme_health_information_page {
    pub critical_warning: spdk_nvme_critical_warning_state,
    pub temperature: u16,
    pub available_spare: u8,
    pub available_spare_threshold: u8,
    pub percentage_used: u8,
    pub reserved: [u8; 26usize],
    pub data_units_read: [u64; 2usize],
    pub data_units_written: [u64; 2usize],
    pub host_read_commands: [u64; 2usize],
    pub host_write_commands: [u64; 2usize],
    pub controller_busy_time: [u64; 2usize],
    pub power_cycles: [u64; 2usize],
    pub power_on_hours: [u64; 2usize],
    pub unsafe_shutdowns: [u64; 2usize],
    pub media_errors: [u64; 2usize],
    pub num_error_info_log_entries: [u64; 2usize],
    pub reserved2: [u8; 320usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_health_information_page() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_health_information_page>() ,
               512usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_health_information_page )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_health_information_page>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_health_information_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                critical_warning as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                critical_warning ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                temperature as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                temperature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                available_spare as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                available_spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                available_spare_threshold as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                available_spare_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                percentage_used as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                percentage_used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                reserved as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                data_units_read as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                data_units_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                data_units_written as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                data_units_written ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                host_read_commands as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                host_read_commands ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                host_write_commands as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                host_write_commands ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                controller_busy_time as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                controller_busy_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                power_cycles as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                power_cycles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                power_on_hours as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                power_on_hours ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                unsafe_shutdowns as * const _ as usize } , 144usize , concat !
                (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                unsafe_shutdowns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                media_errors as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                media_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                num_error_info_log_entries as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                num_error_info_log_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                reserved2 as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                reserved2 ) ));
}
impl Default for spdk_nvme_health_information_page {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/**
 * Firmware slot information page (\ref SPDK_NVME_LOG_FIRMWARE_SLOT)
 */
#[repr(C)]
pub struct spdk_nvme_firmware_page {
    pub afi: spdk_nvme_firmware_page__bindgen_ty_1,
    pub reserved: [u8; 7usize],
    pub revision: [u64; 7usize],
    pub reserved2: [u8; 448usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_firmware_page__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_firmware_page__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_firmware_page__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_firmware_page__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_firmware_page__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_firmware_page__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_firmware_page__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_firmware_page__bindgen_ty_1 {
    #[inline]
    pub fn slot(&self) -> u8 {
        let mask = 7usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_slot(&mut self, val: u8) {
        let mask = 7usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mask = 248usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 248usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_firmware_page() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_firmware_page>() , 512usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_firmware_page ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_firmware_page>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_firmware_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_firmware_page ) ) . afi as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_firmware_page
                ) , "::" , stringify ! ( afi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_firmware_page ) ) . reserved as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_firmware_page
                ) , "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_firmware_page ) ) . revision as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_firmware_page
                ) , "::" , stringify ! ( revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_firmware_page ) ) . reserved2
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_firmware_page
                ) , "::" , stringify ! ( reserved2 ) ));
}
impl Default for spdk_nvme_firmware_page {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/**
 * Namespace attachment Type Encoding
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_ns_attach_type {
    SPDK_NVME_NS_CTRLR_ATTACH = 0,
    SPDK_NVME_NS_CTRLR_DETACH = 1,
}
#[repr(u32)]
/**
 * Namespace management Type Encoding
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_ns_management_type {
    SPDK_NVME_NS_MANAGEMENT_CREATE = 0,
    SPDK_NVME_NS_MANAGEMENT_DELETE = 1,
}
#[repr(C)]
pub struct spdk_nvme_ns_list {
    pub ns_list: [u32; 1024usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_list() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_list>() , 4096usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_ns_list ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_list>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_list ) ) . ns_list as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_list ) ,
                "::" , stringify ! ( ns_list ) ));
}
impl Default for spdk_nvme_ns_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct spdk_nvme_ctrlr_list {
    pub ctrlr_count: u16,
    pub ctrlr_list: [u16; 2047usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_list() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_list>() , 4096usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_list )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_list>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_ctrlr_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_list ) ) . ctrlr_count as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_list )
                , "::" , stringify ! ( ctrlr_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_list ) ) . ctrlr_list as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_list )
                , "::" , stringify ! ( ctrlr_list ) ));
}
impl Default for spdk_nvme_ctrlr_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_secure_erase_setting {
    SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE = 0,
    SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE = 1,
    SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_pi_location {
    SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL = 0,
    SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_pi_type {
    SPDK_NVME_FMT_NVM_PROTECTION_DISABLE = 0,
    SPDK_NVME_FMT_NVM_PROTECTION_TYPE1 = 1,
    SPDK_NVME_FMT_NVM_PROTECTION_TYPE2 = 2,
    SPDK_NVME_FMT_NVM_PROTECTION_TYPE3 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_metadata_setting {
    SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER = 0,
    SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA = 1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_format {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_format() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_format>() , 4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_format ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_format>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( spdk_nvme_format ) ));
}
impl Clone for spdk_nvme_format {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_format {
    #[inline]
    pub fn lbaf(&self) -> u32 {
        let mask = 15usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lbaf(&mut self, val: u32) {
        let mask = 15usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn ms(&self) -> u32 {
        let mask = 16usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ms(&mut self, val: u32) {
        let mask = 16usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn pi(&self) -> u32 {
        let mask = 224usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pi(&mut self, val: u32) {
        let mask = 224usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn pil(&self) -> u32 {
        let mask = 256usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pil(&mut self, val: u32) {
        let mask = 256usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn ses(&self) -> u32 {
        let mask = 3584usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ses(&mut self, val: u32) {
        let mask = 3584usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 9usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mask = 4294963200usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294963200usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 12usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_protection_info {
    pub guard: u16,
    pub app_tag: u16,
    pub ref_tag: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_protection_info() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_protection_info>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_protection_info ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_protection_info>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_protection_info )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_protection_info ) ) . guard as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_protection_info ) , "::" , stringify ! ( guard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_protection_info ) ) . app_tag
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_protection_info ) , "::" , stringify ! ( app_tag )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_protection_info ) ) . ref_tag
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_protection_info ) , "::" , stringify ! ( ref_tag )
                ));
}
impl Clone for spdk_nvme_protection_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/** Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10: commit action */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_fw_commit_action {
    SPDK_NVME_FW_COMMIT_REPLACE_IMG = 0,
    SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG = 1,
    SPDK_NVME_FW_COMMIT_ENABLE_IMG = 2,
    SPDK_NVME_FW_COMMIT_RUN_IMG = 3,
}
/** Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10 */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_fw_commit {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_fw_commit() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_fw_commit>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_fw_commit ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_fw_commit>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_fw_commit ) ));
}
impl Clone for spdk_nvme_fw_commit {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_fw_commit {
    #[inline]
    pub fn fs(&self) -> u32 {
        let mask = 7usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_fs(&mut self, val: u32) {
        let mask = 7usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn ca(&self) -> u32 {
        let mask = 56usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ca(&mut self, val: u32) {
        let mask = 56usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mask = 4294967232usize as u32;
        let field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967232usize as u32;
        let val = val as u32 as u32;
        let mut field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 6usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[repr(u32)]
/**
 * Address family types
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvmf_adrfam {
    SPDK_NVMF_ADRFAM_IPV4 = 1,
    SPDK_NVMF_ADRFAM_IPV6 = 2,
    SPDK_NVMF_ADRFAM_IB = 3,
    SPDK_NVMF_ADRFAM_FC = 4,
    SPDK_NVMF_ADRFAM_INTRA_HOST = 254,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr([u8; 0]);
/**
 * \brief NVMe controller initialization options.
 *
 * A pointer to this structure will be provided for each probe callback from spdk_nvme_probe() to
 * allow the user to request non-default options, and the actual options enabled on the controller
 * will be provided during the attach callback.
 */
#[repr(C)]
pub struct spdk_nvme_ctrlr_opts {
    /**
	 * Number of I/O queues to request (used to set Number of Queues feature)
	 */
    pub num_io_queues: u32,
    /**
	 * Enable submission queue in controller memory buffer
	 */
    pub use_cmb_sqs: bool,
    /**
	 * Type of arbitration mechanism
	 */
    pub arb_mechanism: spdk_nvme_cc_ams,
    /**
	 * Keep alive timeout in milliseconds (0 = disabled).
	 *
	 * The NVMe library will set the Keep Alive Timer feature to this value and automatically
	 * send Keep Alive commands as needed.  The library user must call
	 * spdk_nvme_ctrlr_process_admin_completions() periodically to ensure Keep Alive commands
	 * are sent.
	 */
    pub keep_alive_timeout_ms: u32,
    /**
	 * Specify the retry number when there is issue with the transport
	 */
    pub transport_retry_count: ::std::os::raw::c_int,
    /**
	 * The queue depth of each NVMe I/O queue.
	 */
    pub io_queue_size: u32,
    /**
	 * The host NQN to use when connecting to NVMe over Fabrics controllers.
	 *
	 * Unused for local PCIe-attached NVMe devices.
	 */
    pub hostnqn: [::std::os::raw::c_char; 224usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_opts() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_opts>() , 248usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_opts )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_opts>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_ctrlr_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . num_io_queues
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( num_io_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . use_cmb_sqs as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( use_cmb_sqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . arb_mechanism
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( arb_mechanism ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) .
                keep_alive_timeout_ms as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( keep_alive_timeout_ms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) .
                transport_retry_count as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( transport_retry_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . io_queue_size
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( io_queue_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . hostnqn as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( hostnqn ) ));
}
impl Default for spdk_nvme_ctrlr_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/**
 * NVMe library transports
 *
 * NOTE: These are mapped directly to the NVMe over Fabrics TRTYPE values, except for PCIe,
 * which is a special case since NVMe over Fabrics does not define a TRTYPE for local PCIe.
 *
 * Currently, this uses 256 for PCIe which is intentionally outside of the 8-bit range of TRTYPE.
 * If the NVMe-oF specification ever defines a PCIe TRTYPE, this should be updated.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_transport_type {
    SPDK_NVME_TRANSPORT_PCIE = 256,
    SPDK_NVME_TRANSPORT_RDMA = 1,
}
/**
 * NVMe transport identifier.
 *
 * This identifies a unique endpoint on an NVMe fabric.
 *
 * A string representation of a transport ID may be converted to this type using
 * spdk_nvme_transport_id_parse().
 */
#[repr(C)]
pub struct spdk_nvme_transport_id {
    /**
	 * NVMe transport type.
	 */
    pub trtype: spdk_nvme_transport_type,
    /**
	 * Address family of the transport address.
	 *
	 * For PCIe, this value is ignored.
	 */
    pub adrfam: spdk_nvmf_adrfam,
    /**
	 * Transport address of the NVMe-oF endpoint. For transports which use IP
	 * addressing (e.g. RDMA), this should be an IP address. For PCIe, this
	 * can either be a zero length string (the whole bus) or a PCI address
	 * in the format DDDD:BB:DD.FF
	 */
    pub traddr: [::std::os::raw::c_char; 257usize],
    /**
	 * Transport service id of the NVMe-oF endpoint.  For transports which use
	 * IP addressing (e.g. RDMA), this field shoud be the port number. For PCIe,
	 * this is always a zero length string.
	 */
    pub trsvcid: [::std::os::raw::c_char; 33usize],
    /**
	 * Subsystem NQN of the NVMe over Fabrics endpoint. May be a zero length string.
	 */
    pub subnqn: [::std::os::raw::c_char; 224usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_transport_id() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_transport_id>() , 524usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_transport_id )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_transport_id>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_transport_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . trtype as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( trtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . adrfam as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( adrfam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . traddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( traddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . trsvcid as *
                const _ as usize } , 265usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( trsvcid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . subnqn as *
                const _ as usize } , 298usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( subnqn ) ));
}
impl Default for spdk_nvme_transport_id {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    /**
 * Parse the string representation of a transport ID.
 *
 * \param trid Output transport ID structure (must be allocated and initialized by caller).
 * \param str Input string representation of a transport ID to parse.
 * \return 0 if parsing was successful and trid is filled out, or negated errno values on failure.
 *
 * str must be a zero-terminated C string containing one or more key:value pairs separated by
 * whitespace.
 *
 * Key          | Value
 * ------------ | -----
 * trtype       | Transport type (e.g. PCIe, RDMA)
 * adrfam       | Address family (e.g. IPv4, IPv6)
 * traddr       | Transport address (e.g. 0000:04:00.0 for PCIe or 192.168.100.8 for RDMA)
 * trsvcid      | Transport service identifier (e.g. 4420)
 * subnqn       | Subsystem NQN
 *
 * Unspecified fields of trid are left unmodified, so the caller must initialize trid (for example,
 * memset() to 0) before calling this function.
 */
    pub fn spdk_nvme_transport_id_parse(trid: *mut spdk_nvme_transport_id,
                                        str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Parse the string representation of a transport ID tranport type.
 *
 * \param trtype Output transport type (allocated by caller).
 * \param str Input string representation of transport type (e.g. "PCIe", "RDMA")
 * \return 0 if parsing was successful and trtype is filled out, or negated errno values on failure.
 */
    pub fn spdk_nvme_transport_id_parse_trtype(trtype:
                                                   *mut spdk_nvme_transport_type,
                                               str:
                                                   *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Parse the string representation of a tranport ID address family.
 *
 * \param adrfam Output address family (allocated by caller).
 * \param str Input string representation of address family (e.g. "IPv4", "IPv6")
 * \return 0 if parsing was successful and adrfam is filled out, or negated errno values on failure.
 */
    pub fn spdk_nvme_transport_id_parse_adrfam(adrfam: *mut spdk_nvmf_adrfam,
                                               str:
                                                   *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Compare two transport IDs.
 *
 * \param trid1 First transport ID to compare.
 * \param trid2 Second transport ID to compare.
 *
 * \return 0 if trid1 == trid2, less than 0 if trid1 < trid2, greater than 0 if trid1 > trid2.
 *
 * The result of this function may be used to sort transport IDs in a consistent order; however,
 * the comparison result is not guaranteed to be consistent across library versions.
 *
 * This function uses a case-insensitive comparison for string fields, but it does not otherwise
 * normalize the transport ID. It is the caller's responsibility to provide the transport IDs in
 * a consistent format.
 */
    pub fn spdk_nvme_transport_id_compare(trid1:
                                              *const spdk_nvme_transport_id,
                                          trid2:
                                              *const spdk_nvme_transport_id)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type.
 *
 * \param trtype NVMe over Fabrics transport type to check.
 *
 * \return true if trtype is supported or false if it is not supported.
 */
    pub fn spdk_nvme_transport_available(trtype: spdk_nvme_transport_type)
     -> bool;
}
/**
 * Callback for spdk_nvme_probe() enumeration.
 *
 * \param opts NVMe controller initialization options.  This structure will be populated with the
 * default values on entry, and the user callback may update any options to request a different
 * value.  The controller may not support all requested parameters, so the final values will be
 * provided during the attach callback.
 * \return true to attach to this device.
 */
pub type spdk_nvme_probe_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               trid:
                                                   *const spdk_nvme_transport_id,
                                               opts:
                                                   *mut spdk_nvme_ctrlr_opts)
                              -> bool>;
/**
 * Callback for spdk_nvme_probe() to report a device that has been attached to the userspace NVMe driver.
 *
 * \param opts NVMe controller initialization options that were actually used.  Options may differ
 * from the requested options from the probe call depending on what the controller supports.
 */
pub type spdk_nvme_attach_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               trid:
                                                   *const spdk_nvme_transport_id,
                                               ctrlr: *mut spdk_nvme_ctrlr,
                                               opts:
                                                   *const spdk_nvme_ctrlr_opts)>;
/**
 * Callback for spdk_nvme_probe() to report that a device attached to the userspace NVMe driver
 * has been removed from the system.
 *
 * The controller will remain in a failed state (any new I/O submitted will fail).
 *
 * The controller must be detached from the userspace driver by calling spdk_nvme_detach()
 * once the controller is no longer in use.  It is up to the library user to ensure that
 * no other threads are using the controller before calling spdk_nvme_detach().
 *
 * \param ctrlr NVMe controller instance that was removed.
 */
pub type spdk_nvme_remove_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               ctrlr: *mut spdk_nvme_ctrlr)>;
extern "C" {
    /**
 * \brief Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver
 * to each device found if desired.
 *
 * \param trid The transport ID indicating which bus to enumerate. If the trtype is PCIe or trid is NULL,
 * this will scan the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the
 * location of an NVMe-oF discovery service.
 * \param cb_ctx Opaque value which will be passed back in cb_ctx parameter of the callbacks.
 * \param probe_cb will be called once per NVMe device found in the system.
 * \param attach_cb will be called for devices for which probe_cb returned true once that NVMe
 * controller has been attached to the userspace driver.
 * \param remove_cb will be called for devices that were attached in a previous spdk_nvme_probe()
 * call but are no longer attached to the system. Optional; specify NULL if removal notices are not
 * desired.
 *
 * This function is not thread safe and should only be called from one thread at a time while no
 * other threads are actively using any NVMe devices.
 *
 * If called from a secondary process, only devices that have been attached to the userspace driver
 * in the primary process will be probed.
 *
 * If called more than once, only devices that are not already attached to the SPDK NVMe driver
 * will be reported.
 *
 * To stop using the the controller and release its associated resources,
 * call \ref spdk_nvme_detach with the spdk_nvme_ctrlr instance returned by this function.
 */
    pub fn spdk_nvme_probe(trid: *const spdk_nvme_transport_id,
                           cb_ctx: *mut ::std::os::raw::c_void,
                           probe_cb: spdk_nvme_probe_cb,
                           attach_cb: spdk_nvme_attach_cb,
                           remove_cb: spdk_nvme_remove_cb)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Detaches specified device returned by \ref spdk_nvme_probe()'s attach_cb from the NVMe driver.
 *
 * On success, the spdk_nvme_ctrlr handle is no longer valid.
 *
 * This function should be called from a single thread while no other threads
 * are actively using the NVMe device.
 *
 */
    pub fn spdk_nvme_detach(ctrlr: *mut spdk_nvme_ctrlr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Perform a full hardware reset of the NVMe controller.
 *
 * This function should be called from a single thread while no other threads
 * are actively using the NVMe device.
 *
 * Any pointers returned from spdk_nvme_ctrlr_get_ns() and spdk_nvme_ns_get_data() may be invalidated
 * by calling this function.  The number of namespaces as returned by spdk_nvme_ctrlr_get_num_ns() may
 * also change.
 */
    pub fn spdk_nvme_ctrlr_reset(ctrlr: *mut spdk_nvme_ctrlr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Get the identify controller data as defined by the NVMe specification.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 */
    pub fn spdk_nvme_ctrlr_get_data(ctrlr: *mut spdk_nvme_ctrlr)
     -> *const spdk_nvme_ctrlr_data;
}
extern "C" {
    /**
 * \brief Get the NVMe controller CSTS (Status) register.
 */
    pub fn spdk_nvme_ctrlr_get_regs_csts(ctrlr: *mut spdk_nvme_ctrlr)
     -> spdk_nvme_csts_register;
}
extern "C" {
    /**
 * \brief Get the NVMe controller CAP (Capabilities) register.
 */
    pub fn spdk_nvme_ctrlr_get_regs_cap(ctrlr: *mut spdk_nvme_ctrlr)
     -> spdk_nvme_cap_register;
}
extern "C" {
    /**
 * \brief Get the NVMe controller VS (Version) register.
 */
    pub fn spdk_nvme_ctrlr_get_regs_vs(ctrlr: *mut spdk_nvme_ctrlr)
     -> spdk_nvme_vs_register;
}
extern "C" {
    /**
 * \brief Get the number of namespaces for the given NVMe controller.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 * This is equivalent to calling spdk_nvme_ctrlr_get_data() to get the
 * spdk_nvme_ctrlr_data and then reading the nn field.
 *
 */
    pub fn spdk_nvme_ctrlr_get_num_ns(ctrlr: *mut spdk_nvme_ctrlr) -> u32;
}
extern "C" {
    /**
 * \brief Determine if a particular log page is supported by the given NVMe controller.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 * \sa spdk_nvme_ctrlr_cmd_get_log_page()
 */
    pub fn spdk_nvme_ctrlr_is_log_page_supported(ctrlr: *mut spdk_nvme_ctrlr,
                                                 log_page: u8) -> bool;
}
extern "C" {
    /**
 * \brief Determine if a particular feature is supported by the given NVMe controller.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 * \sa spdk_nvme_ctrlr_cmd_get_feature()
 */
    pub fn spdk_nvme_ctrlr_is_feature_supported(ctrlr: *mut spdk_nvme_ctrlr,
                                                feature_code: u8) -> bool;
}
/**
 * Signature for callback function invoked when a command is completed.
 *
 * The spdk_nvme_cpl parameter contains the completion status.
 */
pub type spdk_nvme_cmd_cb =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *const spdk_nvme_cpl)>;
/**
 * Signature for callback function invoked when an asynchronous error
 *  request command is completed.
 *
 * The aer_cb_arg parameter is set to the context specified by
 *  spdk_nvme_register_aer_callback().
 * The spdk_nvme_cpl parameter contains the completion status of the
 *  asynchronous event request that was completed.
 */
pub type spdk_nvme_aer_cb =
    ::std::option::Option<unsafe extern "C" fn(aer_cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               arg1: *const spdk_nvme_cpl)>;
extern "C" {
    pub fn spdk_nvme_ctrlr_register_aer_callback(ctrlr: *mut spdk_nvme_ctrlr,
                                                 aer_cb_fn: spdk_nvme_aer_cb,
                                                 aer_cb_arg:
                                                     *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_qpair([u8; 0]);
/**
 * Signature for the callback function invoked when a timeout is
 * detected on a request.
 */
pub type spdk_nvme_timeout_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               ctrlr: *mut spdk_nvme_ctrlr,
                                               qpair: *mut spdk_nvme_qpair,
                                               cid: u16)>;
extern "C" {
    /**
 * \brief Register for timeout callback on a controller.
 *
 * The application can choose to register for timeout callback or not register
 * for timeout callback.
 *
 * \param ctrlr NVMe controller on which to monitor for timeout.
 * \param timeout_sec Timeout value in seconds.
 * \param cb_fn A function pointer that points to the callback function
 * \param cb_arg Argument to the callback function.
 */
    pub fn spdk_nvme_ctrlr_register_timeout_callback(ctrlr:
                                                         *mut spdk_nvme_ctrlr,
                                                     timeout_sec: u32,
                                                     cb_fn:
                                                         spdk_nvme_timeout_cb,
                                                     cb_arg:
                                                         *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * \brief Allocate an I/O queue pair (submission and completion queue).
 *
 * Each queue pair should only be used from a single thread at a time (mutual exclusion must be
 * enforced by the user).
 *
 * \param ctrlr NVMe controller for which to allocate the I/O queue pair.
 * \param qprio Queue priority for weighted round robin arbitration.  If a different arbitration
 * method is in use, pass 0.
 */
    pub fn spdk_nvme_ctrlr_alloc_io_qpair(ctrlr: *mut spdk_nvme_ctrlr,
                                          qprio: spdk_nvme_qprio)
     -> *mut spdk_nvme_qpair;
}
extern "C" {
    /**
 * \brief Free an I/O queue pair that was allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 */
    pub fn spdk_nvme_ctrlr_free_io_qpair(qpair: *mut spdk_nvme_qpair)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Send the given NVM I/O command to the NVMe controller.
 *
 * This is a low level interface for submitting I/O commands directly. Prefer
 * the spdk_nvme_ns_cmd_* functions instead. The validity of the command will
 * not be checked!
 *
 * When constructing the nvme_command it is not necessary to fill out the PRP
 * list/SGL or the CID. The driver will handle both of those for you.
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ctrlr_cmd_io_raw(ctrlr: *mut spdk_nvme_ctrlr,
                                      qpair: *mut spdk_nvme_qpair,
                                      cmd: *mut spdk_nvme_cmd,
                                      buf: *mut ::std::os::raw::c_void,
                                      len: u32, cb_fn: spdk_nvme_cmd_cb,
                                      cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Process any outstanding completions for I/O submitted on a queue pair.
 *
 * This call is non-blocking, i.e. it only
 * processes completions that are ready at the time of this function call. It does not
 * wait for outstanding commands to finish.
 *
 * For each completed command, the request's callback function will
 *  be called if specified as non-NULL when the request was submitted.
 *
 * \param qpair Queue pair to check for completions.
 * \param max_completions Limit the number of completions to be processed in one call, or 0
 * for unlimited.
 *
 * \return Number of completions processed (may be 0) or negative on error.
 *
 * \sa spdk_nvme_cmd_cb
 *
 * This function may be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 * The caller must ensure that each queue pair is only used from one thread at a time.
 */
    pub fn spdk_nvme_qpair_process_completions(qpair: *mut spdk_nvme_qpair,
                                               max_completions: u32) -> i32;
}
extern "C" {
    /**
 * \brief Send the given admin command to the NVMe controller.
 *
 * This is a low level interface for submitting admin commands directly. Prefer
 * the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will
 * not be checked!
 *
 * When constructing the nvme_command it is not necessary to fill out the PRP
 * list/SGL or the CID. The driver will handle both of those for you.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 * Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
 * of commands submitted through this function.
 */
    pub fn spdk_nvme_ctrlr_cmd_admin_raw(ctrlr: *mut spdk_nvme_ctrlr,
                                         cmd: *mut spdk_nvme_cmd,
                                         buf: *mut ::std::os::raw::c_void,
                                         len: u32, cb_fn: spdk_nvme_cmd_cb,
                                         cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Process any outstanding completions for admin commands.
 *
 * This will process completions for admin commands submitted on any thread.
 *
 * This call is non-blocking, i.e. it only processes completions that are ready
 * at the time of this function call. It does not wait for outstanding commands to
 * finish.
 *
 * \return Number of completions processed (may be 0) or negative on error.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ctrlr_process_admin_completions(ctrlr:
                                                         *mut spdk_nvme_ctrlr)
     -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns([u8; 0]);
extern "C" {
    /**
 * \brief Get a handle to a namespace for the given controller.
 *
 * Namespaces are numbered from 1 to the total number of namespaces. There will never
 * be any gaps in the numbering. The number of namespaces is obtained by calling
 * spdk_nvme_ctrlr_get_num_ns().
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ctrlr_get_ns(ctrlr: *mut spdk_nvme_ctrlr, ns_id: u32)
     -> *mut spdk_nvme_ns;
}
extern "C" {
    /**
 * \brief Get a specific log page from the NVMe controller.
 *
 * \param ctrlr NVMe controller to query.
 * \param log_page The log page identifier.
 * \param nsid Depending on the log page, this may be 0, a namespace identifier, or SPDK_NVME_GLOBAL_NS_TAG.
 * \param payload The pointer to the payload buffer.
 * \param payload_size The size of payload buffer.
 * \param offset Offset in bytes within the log page to start retrieving log page data.
 *               May only be non-zero if the controller supports extended data for Get Log Page
 *               as reported in the controller data log page attributes.
 * \param cb_fn Callback function to invoke when the log page has been retrieved.
 * \param cb_arg Argument to pass to the callback function.
 *
 * \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 * Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
 * of commands submitted through this function.
 *
 * \sa spdk_nvme_ctrlr_is_log_page_supported()
 */
    pub fn spdk_nvme_ctrlr_cmd_get_log_page(ctrlr: *mut spdk_nvme_ctrlr,
                                            log_page: u8, nsid: u32,
                                            payload:
                                                *mut ::std::os::raw::c_void,
                                            payload_size: u32, offset: u64,
                                            cb_fn: spdk_nvme_cmd_cb,
                                            cb_arg:
                                                *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Abort a specific previously-submitted NVMe command.
 *
 * \param ctrlr NVMe controller to which the command was submitted.
 * \param qpair NVMe queue pair to which the command was submitted.
 * \param cid Command ID of the command to abort.
 * \param cb_fn Callback function to invoke when the abort has completed.
 * \param cb_arg Argument to pass to the callback function.\
 *
 * \return 0 if successfully submitted, negated errno value otherwise.
 *
 * \sa spdk_nvme_ctrlr_register_timeout_callback()
 */
    pub fn spdk_nvme_ctrlr_cmd_abort(ctrlr: *mut spdk_nvme_ctrlr,
                                     qpair: *mut spdk_nvme_qpair, cid: u16,
                                     cb_fn: spdk_nvme_cmd_cb,
                                     cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Set specific feature for the given NVMe controller.
 *
 * \param ctrlr NVMe controller to manipulate.
 * \param feature The feature identifier.
 * \param cdw11 as defined by the specification for this command.
 * \param cdw12 as defined by the specification for this command.
 * \param payload The pointer to the payload buffer.
 * \param payload_size The size of payload buffer.
 * \param cb_fn Callback function to invoke when the feature has been set.
 * \param cb_arg Argument to pass to the callback function.
 *
 * \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 * Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
 * of commands submitted through this function.
 *
 * \sa spdk_nvme_ctrlr_cmd_get_feature()
 */
    pub fn spdk_nvme_ctrlr_cmd_set_feature(ctrlr: *mut spdk_nvme_ctrlr,
                                           feature: u8, cdw11: u32,
                                           cdw12: u32,
                                           payload:
                                               *mut ::std::os::raw::c_void,
                                           payload_size: u32,
                                           cb_fn: spdk_nvme_cmd_cb,
                                           cb_arg:
                                               *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Get specific feature from given NVMe controller.
 *
 * \param ctrlr NVMe controller to query.
 * \param feature The feature identifier.
 * \param cdw11 as defined by the specification for this command.
 * \param payload The pointer to the payload buffer.
 * \param payload_size The size of payload buffer.
 * \param cb_fn Callback function to invoke when the feature has been retrieved.
 * \param cb_arg Argument to pass to the callback function.
 *
 * \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 *
 * Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
 * of commands submitted through this function.
 *
 * \sa spdk_nvme_ctrlr_cmd_set_feature()
 */
    pub fn spdk_nvme_ctrlr_cmd_get_feature(ctrlr: *mut spdk_nvme_ctrlr,
                                           feature: u8, cdw11: u32,
                                           payload:
                                               *mut ::std::os::raw::c_void,
                                           payload_size: u32,
                                           cb_fn: spdk_nvme_cmd_cb,
                                           cb_arg:
                                               *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Attach the specified namespace to controllers.
 *
 * \param ctrlr NVMe controller to use for command submission.
 * \param nsid Namespace identifier for namespace to attach.
 * \param payload The pointer to the controller list.
 *
 * \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
 *
 * This function is thread safe and can be called at any point after spdk_nvme_attach().
 *
 * Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
 * of commands submitted through this function.
 */
    pub fn spdk_nvme_ctrlr_attach_ns(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32,
                                     payload: *mut spdk_nvme_ctrlr_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Detach the specified namespace from controllers.
 *
 * \param ctrlr NVMe controller to use for command submission.
 * \param nsid Namespace ID to detach.
 * \param payload The pointer to the controller list.
 *
 * \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
 *
 * This function is thread safe and can be called at any point after spdk_nvme_attach().
 *
 * Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
 * of commands submitted through this function.
 */
    pub fn spdk_nvme_ctrlr_detach_ns(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32,
                                     payload: *mut spdk_nvme_ctrlr_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Create a namespace.
 *
 * \param ctrlr NVMe controller to create namespace on.
 * \param payload The pointer to the NVMe namespace data.
 *
 * \return Namespace ID (>= 1) if successfully created, or 0 if the request failed.
 *
 * This function is thread safe and can be called at any point after spdk_nvme_attach().
 */
    pub fn spdk_nvme_ctrlr_create_ns(ctrlr: *mut spdk_nvme_ctrlr,
                                     payload: *mut spdk_nvme_ns_data) -> u32;
}
extern "C" {
    /**
 * \brief Delete a namespace.
 *
 * \param ctrlr NVMe controller to delete namespace from.
 * \param nsid The namespace identifier.
 *
 * \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
 *
 * This function is thread safe and can be called at any point after spdk_nvme_attach().
 *
 * Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
 * of commands submitted through this function.
 */
    pub fn spdk_nvme_ctrlr_delete_ns(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Format NVM.
 *
 * This function requests a low-level format of the media.
 *
 * \param ctrlr NVMe controller to format.
 * \param nsid The namespace identifier.  May be SPDK_NVME_GLOBAL_NS_TAG to format all namespaces.
 * \param format The format information for the command.
 *
 * \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
 *
 * This function is thread safe and can be called at any point after spdk_nvme_attach().
 */
    pub fn spdk_nvme_ctrlr_format(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32,
                                  format: *mut spdk_nvme_format)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Download a new firmware image.
 *
 * \param payload The data buffer for the firmware image.
 * \param size The data size will be downloaded.
 * \param slot The slot that the firmware image will be committed to.
 *
 * \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request,
 * -1 if the size is not multiple of 4.
 *
 * This function is thread safe and can be called at any point after spdk_nvme_attach().
 */
    pub fn spdk_nvme_ctrlr_update_firmware(ctrlr: *mut spdk_nvme_ctrlr,
                                           payload:
                                               *mut ::std::os::raw::c_void,
                                           size: u32,
                                           slot: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Get the identify namespace data as defined by the NVMe specification.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_data(ns: *mut spdk_nvme_ns)
     -> *const spdk_nvme_ns_data;
}
extern "C" {
    /**
 * \brief Get the namespace id (index number) from the given namespace handle.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_id(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /**
 * \brief Determine whether a namespace is active.
 *
 * Inactive namespaces cannot be the target of I/O commands.
 */
    pub fn spdk_nvme_ns_is_active(ns: *mut spdk_nvme_ns) -> bool;
}
extern "C" {
    /**
 * \brief Get the maximum transfer size, in bytes, for an I/O sent to the given namespace.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_max_io_xfer_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /**
 * \brief Get the sector size, in bytes, of the given namespace.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_sector_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /**
 * \brief Get the number of sectors for the given namespace.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_num_sectors(ns: *mut spdk_nvme_ns) -> u64;
}
extern "C" {
    /**
 * \brief Get the size, in bytes, of the given namespace.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_size(ns: *mut spdk_nvme_ns) -> u64;
}
extern "C" {
    /**
 * \brief Get the end-to-end data protection information type of the given namespace.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_pi_type(ns: *mut spdk_nvme_ns)
     -> spdk_nvme_pi_type;
}
extern "C" {
    /**
 * \brief Get the metadata size, in bytes, of the given namespace.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_md_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /**
 * \brief True if the namespace can support extended LBA when end-to-end data protection enabled.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_supports_extended_lba(ns: *mut spdk_nvme_ns) -> bool;
}
#[repr(u32)]
/**
 * \brief Namespace command support flags.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_ns_flags {
    SPDK_NVME_NS_DEALLOCATE_SUPPORTED = 1,
    SPDK_NVME_NS_FLUSH_SUPPORTED = 2,
    SPDK_NVME_NS_RESERVATION_SUPPORTED = 4,
    SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED = 8,
    SPDK_NVME_NS_DPS_PI_SUPPORTED = 16,
    SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED = 32,
}
extern "C" {
    /**
 * \brief Get the flags for the given namespace.
 *
 * See spdk_nvme_ns_flags for the possible flags returned.
 *
 * This function is thread safe and can be called at any point while the controller is attached to
 *  the SPDK NVMe driver.
 */
    pub fn spdk_nvme_ns_get_flags(ns: *mut spdk_nvme_ns) -> u32;
}
/**
 * Restart the SGL walk to the specified offset when the command has scattered payloads.
 *
 * The cb_arg parameter is the value passed to readv/writev.
 */
pub type spdk_nvme_req_reset_sgl_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               offset: u32)>;
/**
 * Fill out *address and *length with the current SGL entry and advance to the next
 * entry for the next time the callback is invoked.
 *
 * The cb_arg parameter is the value passed to readv/writev.
 * The address parameter contains the virtual address of this segment.
 * The length parameter contains the length of this physical segment.
 */
pub type spdk_nvme_req_next_sge_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               address:
                                                   *mut *mut ::std::os::raw::c_void,
                                               length: *mut u32)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /**
 * \brief Submits a write I/O to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the write I/O
 * \param qpair I/O queue pair to submit the request
 * \param payload virtual address pointer to the data payload
 * \param lba starting LBA to write the data
 * \param lba_count length (in sectors) for the write operation
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 * \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
 * 			in spdk/nvme_spec.h, for this I/O.
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_write(ns: *mut spdk_nvme_ns,
                                  qpair: *mut spdk_nvme_qpair,
                                  payload: *mut ::std::os::raw::c_void,
                                  lba: u64, lba_count: u32,
                                  cb_fn: spdk_nvme_cmd_cb,
                                  cb_arg: *mut ::std::os::raw::c_void,
                                  io_flags: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a write I/O to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the write I/O
 * \param qpair I/O queue pair to submit the request
 * \param lba starting LBA to write the data
 * \param lba_count length (in sectors) for the write operation
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 * \param io_flags set flags, defined in nvme_spec.h, for this I/O
 * \param reset_sgl_fn callback function to reset scattered payload
 * \param next_sge_fn callback function to iterate each scattered
 * payload memory segment
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_writev(ns: *mut spdk_nvme_ns,
                                   qpair: *mut spdk_nvme_qpair, lba: u64,
                                   lba_count: u32, cb_fn: spdk_nvme_cmd_cb,
                                   cb_arg: *mut ::std::os::raw::c_void,
                                   io_flags: u32,
                                   reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
                                   next_sge_fn: spdk_nvme_req_next_sge_cb)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a write I/O to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the write I/O
 * \param qpair I/O queue pair to submit the request
 * \param payload virtual address pointer to the data payload
 * \param metadata virtual address pointer to the metadata payload, the length
 *	           of metadata is specified by spdk_nvme_ns_get_md_size()
 * \param lba starting LBA to write the data
 * \param lba_count length (in sectors) for the write operation
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 * \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
 * 			in spdk/nvme_spec.h, for this I/O.
 * \param apptag_mask application tag mask.
 * \param apptag application tag to use end-to-end protection information.
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_write_with_md(ns: *mut spdk_nvme_ns,
                                          qpair: *mut spdk_nvme_qpair,
                                          payload:
                                              *mut ::std::os::raw::c_void,
                                          metadata:
                                              *mut ::std::os::raw::c_void,
                                          lba: u64, lba_count: u32,
                                          cb_fn: spdk_nvme_cmd_cb,
                                          cb_arg: *mut ::std::os::raw::c_void,
                                          io_flags: u32, apptag_mask: u16,
                                          apptag: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a write zeroes I/O to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the write zeroes I/O
 * \param qpair I/O queue pair to submit the request
 * \param lba starting LBA for this command
 * \param lba_count length (in sectors) for the write zero operation
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 * \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
 * 			in spdk/nvme_spec.h, for this I/O.
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_write_zeroes(ns: *mut spdk_nvme_ns,
                                         qpair: *mut spdk_nvme_qpair,
                                         lba: u64, lba_count: u32,
                                         cb_fn: spdk_nvme_cmd_cb,
                                         cb_arg: *mut ::std::os::raw::c_void,
                                         io_flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a read I/O to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the read I/O
 * \param qpair I/O queue pair to submit the request
 * \param payload virtual address pointer to the data payload
 * \param lba starting LBA to read the data
 * \param lba_count length (in sectors) for the read operation
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 * \param io_flags set flags, defined in nvme_spec.h, for this I/O
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_read(ns: *mut spdk_nvme_ns,
                                 qpair: *mut spdk_nvme_qpair,
                                 payload: *mut ::std::os::raw::c_void,
                                 lba: u64, lba_count: u32,
                                 cb_fn: spdk_nvme_cmd_cb,
                                 cb_arg: *mut ::std::os::raw::c_void,
                                 io_flags: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a read I/O to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the read I/O
 * \param qpair I/O queue pair to submit the request
 * \param lba starting LBA to read the data
 * \param lba_count length (in sectors) for the read operation
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 * \param io_flags set flags, defined in nvme_spec.h, for this I/O
 * \param reset_sgl_fn callback function to reset scattered payload
 * \param next_sge_fn callback function to iterate each scattered
 * payload memory segment
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_readv(ns: *mut spdk_nvme_ns,
                                  qpair: *mut spdk_nvme_qpair, lba: u64,
                                  lba_count: u32, cb_fn: spdk_nvme_cmd_cb,
                                  cb_arg: *mut ::std::os::raw::c_void,
                                  io_flags: u32,
                                  reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
                                  next_sge_fn: spdk_nvme_req_next_sge_cb)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a read I/O to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the read I/O
 * \param qpair I/O queue pair to submit the request
 * \param payload virtual address pointer to the data payload
 * \param metadata virtual address pointer to the metadata payload, the length
 *	           of metadata is specified by spdk_nvme_ns_get_md_size()
 * \param lba starting LBA to read the data
 * \param lba_count length (in sectors) for the read operation
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 * \param io_flags set flags, defined in nvme_spec.h, for this I/O
 * \param apptag_mask application tag mask.
 * \param apptag application tag to use end-to-end protection information.
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_read_with_md(ns: *mut spdk_nvme_ns,
                                         qpair: *mut spdk_nvme_qpair,
                                         payload: *mut ::std::os::raw::c_void,
                                         metadata:
                                             *mut ::std::os::raw::c_void,
                                         lba: u64, lba_count: u32,
                                         cb_fn: spdk_nvme_cmd_cb,
                                         cb_arg: *mut ::std::os::raw::c_void,
                                         io_flags: u32, apptag_mask: u16,
                                         apptag: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a data set management request to the specified NVMe namespace. Data set
 *        management operations are designed to optimize interaction with the block
 *        translation layer inside the device. The most common type of operation is
 *        deallocate, which is often referred to as TRIM or UNMAP.
 *
 * \param ns NVMe namespace to submit the DSM request
 * \param type A bit field constructed from \ref enum spdk_nvme_dsm_attribute.
 * \param qpair I/O queue pair to submit the request
 * \param ranges An array of \ref spdk_nvme_dsm_range elements describing
 		 the LBAs to operate on.
 * \param num_ranges The number of elements in the ranges array.
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 *
 * \return 0 if successfully submitted, negated POSIX errno values otherwise.
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 *
 * This is a convenience wrapper that will automatically allocate and construct the correct
 * data buffers. Therefore, ranges does not need to be allocated from pinned memory and
 * can be placed on the stack. If a higher performance, zero-copy version of DSM is
 * required, simply build and submit a raw command using spdk_nvme_ctrlr_cmd_io_raw().
 */
    pub fn spdk_nvme_ns_cmd_dataset_management(ns: *mut spdk_nvme_ns,
                                               qpair: *mut spdk_nvme_qpair,
                                               type_: u32,
                                               ranges:
                                                   *const spdk_nvme_dsm_range,
                                               num_ranges: u16,
                                               cb_fn: spdk_nvme_cmd_cb,
                                               cb_arg:
                                                   *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a flush request to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the flush request
 * \param qpair I/O queue pair to submit the request
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_flush(ns: *mut spdk_nvme_ns,
                                  qpair: *mut spdk_nvme_qpair,
                                  cb_fn: spdk_nvme_cmd_cb,
                                  cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a reservation register to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the reservation register request
 * \param qpair I/O queue pair to submit the request
 * \param payload virtual address pointer to the reservation register data
 * \param ignore_key '1' the current reservation key check is disabled
 * \param action specifies the registration action
 * \param cptpl change the Persist Through Power Loss state
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_reservation_register(ns: *mut spdk_nvme_ns,
                                                 qpair: *mut spdk_nvme_qpair,
                                                 payload:
                                                     *mut spdk_nvme_reservation_register_data,
                                                 ignore_key: bool,
                                                 action:
                                                     spdk_nvme_reservation_register_action,
                                                 cptpl:
                                                     spdk_nvme_reservation_register_cptpl,
                                                 cb_fn: spdk_nvme_cmd_cb,
                                                 cb_arg:
                                                     *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a reservation release to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the reservation release request
 * \param qpair I/O queue pair to submit the request
 * \param payload virtual address pointer to current reservation key
 * \param ignore_key '1' the current reservation key check is disabled
 * \param action specifies the reservation release action
 * \param type reservation type for the namespace
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_reservation_release(ns: *mut spdk_nvme_ns,
                                                qpair: *mut spdk_nvme_qpair,
                                                payload:
                                                    *mut spdk_nvme_reservation_key_data,
                                                ignore_key: bool,
                                                action:
                                                    spdk_nvme_reservation_release_action,
                                                type_:
                                                    spdk_nvme_reservation_type,
                                                cb_fn: spdk_nvme_cmd_cb,
                                                cb_arg:
                                                    *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a reservation acquire to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the reservation acquire request
 * \param qpair I/O queue pair to submit the request
 * \param payload virtual address pointer to reservation acquire data
 * \param ignore_key '1' the current reservation key check is disabled
 * \param action specifies the reservation acquire action
 * \param type reservation type for the namespace
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_reservation_acquire(ns: *mut spdk_nvme_ns,
                                                qpair: *mut spdk_nvme_qpair,
                                                payload:
                                                    *mut spdk_nvme_reservation_acquire_data,
                                                ignore_key: bool,
                                                action:
                                                    spdk_nvme_reservation_acquire_action,
                                                type_:
                                                    spdk_nvme_reservation_type,
                                                cb_fn: spdk_nvme_cmd_cb,
                                                cb_arg:
                                                    *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \brief Submits a reservation report to the specified NVMe namespace.
 *
 * \param ns NVMe namespace to submit the reservation report request
 * \param qpair I/O queue pair to submit the request
 * \param payload virtual address pointer for reservation status data
 * \param len length bytes for reservation status data structure
 * \param cb_fn callback function to invoke when the I/O is completed
 * \param cb_arg argument to pass to the callback function
 *
 * \return 0 if successfully submitted, ENOMEM if an nvme_request
 *	     structure cannot be allocated for the I/O request
 *
 * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
 * The user must ensure that only one thread submits I/O on a given qpair at any given time.
 */
    pub fn spdk_nvme_ns_cmd_reservation_report(ns: *mut spdk_nvme_ns,
                                               qpair: *mut spdk_nvme_qpair,
                                               payload:
                                                   *mut ::std::os::raw::c_void,
                                               len: u32,
                                               cb_fn: spdk_nvme_cmd_cb,
                                               cb_arg:
                                                   *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
