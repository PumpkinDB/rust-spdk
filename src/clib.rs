/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
/// \brief Environment initialization options
#[repr(C)]
#[derive(Debug, Copy)]
pub struct spdk_env_opts {
    pub name: *const ::std::os::raw::c_char,
    pub core_mask: *const ::std::os::raw::c_char,
    pub shm_id: ::std::os::raw::c_int,
    pub mem_channel: ::std::os::raw::c_int,
    pub master_core: ::std::os::raw::c_int,
    pub mem_size: ::std::os::raw::c_int,
    pub no_pci: bool,
}
#[test]
fn bindgen_test_layout_spdk_env_opts() {
    assert_eq!(::std::mem::size_of::<spdk_env_opts>() , 40usize , concat ! (
               "Size of: " , stringify ! ( spdk_env_opts ) ));
    assert_eq! (::std::mem::align_of::<spdk_env_opts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( spdk_env_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . core_mask as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( core_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . shm_id as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( shm_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . mem_channel as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( mem_channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . master_core as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( master_core ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . mem_size as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( mem_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_env_opts ) ) . no_pci as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_env_opts ) , "::"
                , stringify ! ( no_pci ) ));
}
impl Clone for spdk_env_opts {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_env_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    /// \brief Initialize the default value of opts
    pub fn spdk_env_opts_init(opts: *mut spdk_env_opts);
}
extern "C" {
    /// \brief Initialize the environment library. This must be called prior to using
/// any other functions in this library.
    pub fn spdk_env_init(opts: *const spdk_env_opts);
}
extern "C" {
    /// Allocate a pinned, physically contiguous memory buffer with the
/// given size and alignment.
    pub fn spdk_dma_malloc(size: usize, align: usize, phys_addr: *mut u64)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate a pinned, physically contiguous memory buffer with the
/// given size, alignment and socket id.
    pub fn spdk_dma_malloc_socket(size: usize, align: usize,
                                  phys_addr: *mut u64,
                                  socket_id: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate a pinned, physically contiguous memory buffer with the
/// given size and alignment. The buffer will be zeroed.
    pub fn spdk_dma_zmalloc(size: usize, align: usize, phys_addr: *mut u64)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate a pinned, physically contiguous memory buffer with the
/// given size, alignment and socket id. The buffer will be zeroed.
    pub fn spdk_dma_zmalloc_socket(size: usize, align: usize,
                                   phys_addr: *mut u64,
                                   socket_id: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Resize the allocated and pinned memory buffer with the given
/// new size and alignment. Existing contents are preserved.
    pub fn spdk_dma_realloc(buf: *mut ::std::os::raw::c_void, size: usize,
                            align: usize, phys_addr: *mut u64)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Free a memory buffer previously allocated with spdk_dma_zmalloc.
/// This call is never made from the performance path.
    pub fn spdk_dma_free(buf: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_mempool {
    _unused: [u8; 0],
}
extern "C" {
    /// Create a thread-safe memory pool. Cache size is the number of
/// elements in a thread-local cache. Can be 0 for no caching, or -1
/// for unspecified.
///
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.
    pub fn spdk_mempool_create(name: *const ::std::os::raw::c_char,
                               count: usize, ele_size: usize,
                               cache_size: usize,
                               socket_id: ::std::os::raw::c_int)
     -> *mut spdk_mempool;
}
extern "C" {
    /// Free a memory pool.
    pub fn spdk_mempool_free(mp: *mut spdk_mempool);
}
extern "C" {
    /// Get an element from a memory pool. If no elements remain, return NULL.
    pub fn spdk_mempool_get(mp: *mut spdk_mempool)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Put an element back into the memory pool.
    pub fn spdk_mempool_put(mp: *mut spdk_mempool,
                            ele: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Put multiple elements back into the memory pool.
    pub fn spdk_mempool_put_bulk(mp: *mut spdk_mempool,
                                 ele_arr:
                                     *const *const ::std::os::raw::c_void,
                                 count: usize);
}
extern "C" {
    /// Return the number of entries in the mempool.
    pub fn spdk_mempool_count(pool: *const spdk_mempool) -> usize;
}
extern "C" {
    /// \brief Return the number of dedicated CPU cores utilized by
/// this env abstraction
    pub fn spdk_env_get_core_count() -> u32;
}
extern "C" {
    /// \brief Return the CPU core index of the current thread. This
/// will only function when called from threads set up by
/// this environment abstraction.
    pub fn spdk_env_get_current_core() -> u32;
}
extern "C" {
    /// \brief Return the index of the first dedicated CPU core for
/// this application.
    pub fn spdk_env_get_first_core() -> u32;
}
extern "C" {
    /// \brief Return the index of the next dedicated CPU core for
/// this application.
/// If there is no next core, return UINT32_MAX.
    pub fn spdk_env_get_next_core(prev_core: u32) -> u32;
}
extern "C" {
    /// \brief Return the socket ID for the given core.
    pub fn spdk_env_get_socket_id(core: u32) -> u32;
}
pub type thread_start_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// \brief Launch a thread pinned to the given core. Only a single pinned thread
/// may be launched per core. Subsequent attempts to launch pinned threads on
/// that core will fail.
///
/// \param core The core to pin the thread to.
/// \param fn Entry point on the new thread.
/// \param arg Argument apssed to thread_start_fn
    pub fn spdk_env_thread_launch_pinned(core: u32, fn_: thread_start_fn,
                                         arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Wait for all threads to exit before returning.
    pub fn spdk_env_thread_wait_all();
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cap_register {
    pub raw: u64,
    pub bits: spdk_nvme_cap_register__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cap_register__bindgen_ty_1 {
    pub _bitfield_1: [u16; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cap_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cap_register__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_cap_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cap_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cap_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_cap_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_cap_register__bindgen_ty_1 {
    #[inline]
    pub fn mqes(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 65535u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mqes(&mut self, val: u32) {
        let mask = 65535u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn cqr(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 65536u64 as u64;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_cqr(&mut self, val: u32) {
        let mask = 65536u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn ams(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 393216u64 as u64;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ams(&mut self, val: u32) {
        let mask = 393216u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16252928u64 as u64;
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 16252928u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn to(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4278190080u64 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_to(&mut self, val: u32) {
        let mask = 4278190080u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn dstrd(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 64424509440u64 as u64;
        let val = (unit_field_val & mask) >> 32usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dstrd(&mut self, val: u32) {
        let mask = 64424509440u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 32usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn nssrs(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 68719476736u64 as u64;
        let val = (unit_field_val & mask) >> 36usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_nssrs(&mut self, val: u32) {
        let mask = 68719476736u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 36usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn css_nvm(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 137438953472u64 as u64;
        let val = (unit_field_val & mask) >> 37usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_css_nvm(&mut self, val: u32) {
        let mask = 137438953472u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 37usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn css_reserved(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1924145348608u64 as u64;
        let val = (unit_field_val & mask) >> 38usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_css_reserved(&mut self, val: u32) {
        let mask = 1924145348608u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 38usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 279275953455104u64 as u64;
        let val = (unit_field_val & mask) >> 41usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 279275953455104u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 41usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mpsmin(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4222124650659840u64 as u64;
        let val = (unit_field_val & mask) >> 48usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mpsmin(&mut self, val: u32) {
        let mask = 4222124650659840u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 48usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mpsmax(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 67553994410557440u64 as u64;
        let val = (unit_field_val & mask) >> 52usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mpsmax(&mut self, val: u32) {
        let mask = 67553994410557440u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 52usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18374686479671623680u64 as u64;
        let val = (unit_field_val & mask) >> 56usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        let mask = 18374686479671623680u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 56usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(mqes: u32, cqr: u32, ams: u32, reserved1: u32,
                          to: u32, dstrd: u32, nssrs: u32, css_nvm: u32,
                          css_reserved: u32, reserved2: u32, mpsmin: u32,
                          mpsmax: u32, reserved3: u32) -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({ 0 } |
                                                                         ((mqes
                                                                               as
                                                                               u32
                                                                               as
                                                                               u64)
                                                                              <<
                                                                              0usize)
                                                                             &
                                                                             (65535u64
                                                                                  as
                                                                                  u64))
                                                                } |
                                                                    ((cqr as
                                                                          u32
                                                                          as
                                                                          u64)
                                                                         <<
                                                                         16usize)
                                                                        &
                                                                        (65536u64
                                                                             as
                                                                             u64))
                                                           } |
                                                               ((ams as u32 as
                                                                     u64) <<
                                                                    17usize) &
                                                                   (393216u64
                                                                        as
                                                                        u64))
                                                      } |
                                                          ((reserved1 as u32
                                                                as u64) <<
                                                               19usize) &
                                                              (16252928u64 as
                                                                   u64))
                                                 } |
                                                     ((to as u32 as u64) <<
                                                          24usize) &
                                                         (4278190080u64 as
                                                              u64))
                                            } |
                                                ((dstrd as u32 as u64) <<
                                                     32usize) &
                                                    (64424509440u64 as u64))
                                       } |
                                           ((nssrs as u32 as u64) << 36usize)
                                               & (68719476736u64 as u64))
                                  } |
                                      ((css_nvm as u32 as u64) << 37usize) &
                                          (137438953472u64 as u64))
                             } |
                                 ((css_reserved as u32 as u64) << 38usize) &
                                     (1924145348608u64 as u64))
                        } |
                            ((reserved2 as u32 as u64) << 41usize) &
                                (279275953455104u64 as u64))
                   } |
                       ((mpsmin as u32 as u64) << 48usize) &
                           (4222124650659840u64 as u64))
              } |
                  ((mpsmax as u32 as u64) << 52usize) &
                      (67553994410557440u64 as u64))
         } |
             ((reserved3 as u32 as u64) << 56usize) &
                 (18374686479671623680u64 as u64))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cap_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cap_register>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_cap_register )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cap_register>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cap_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cap_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cap_register
                ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cap_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cap_register
                ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_cap_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cap_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cc_register {
    pub raw: u32,
    pub bits: spdk_nvme_cc_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cc_register__bindgen_ty_1 {
    pub _bitfield_1: [u8; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cc_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cc_register__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cc_register__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cc_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cc_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_cc_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_cc_register__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 14u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 14u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn css(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 112u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_css(&mut self, val: u32) {
        let mask = 112u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mps(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1920u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: u32) {
        let mask = 1920u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ams(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 14336u64 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ams(&mut self, val: u32) {
        let mask = 14336u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn shn(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 49152u64 as u32;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_shn(&mut self, val: u32) {
        let mask = 49152u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn iosqes(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 983040u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_iosqes(&mut self, val: u32) {
        let mask = 983040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn iocqes(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 15728640u64 as u32;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_iocqes(&mut self, val: u32) {
        let mask = 15728640u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(en: u32, reserved1: u32, css: u32, mps: u32,
                          ams: u32, shn: u32, iosqes: u32, iocqes: u32,
                          reserved2: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((en as u32 as u32) <<
                                                          0usize) &
                                                         (1u64 as u32))
                                            } |
                                                ((reserved1 as u32 as u32) <<
                                                     1usize) & (14u64 as u32))
                                       } |
                                           ((css as u32 as u32) << 4usize) &
                                               (112u64 as u32))
                                  } |
                                      ((mps as u32 as u32) << 7usize) &
                                          (1920u64 as u32))
                             } |
                                 ((ams as u32 as u32) << 11usize) &
                                     (14336u64 as u32))
                        } |
                            ((shn as u32 as u32) << 14usize) &
                                (49152u64 as u32))
                   } |
                       ((iosqes as u32 as u32) << 16usize) &
                           (983040u64 as u32))
              } | ((iocqes as u32 as u32) << 20usize) & (15728640u64 as u32))
         } | ((reserved2 as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cc_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cc_register>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_cc_register )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cc_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cc_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cc_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cc_register )
                , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cc_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cc_register )
                , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_cc_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cc_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_shn_value {
    SPDK_NVME_SHN_NORMAL = 1,
    SPDK_NVME_SHN_ABRUPT = 2,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_csts_register {
    pub raw: u32,
    pub bits: spdk_nvme_csts_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_csts_register__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_csts_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_csts_register__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_csts_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_csts_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_csts_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_csts_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_csts_register__bindgen_ty_1 {
    #[inline]
    pub fn rdy(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rdy(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn cfs(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_cfs(&mut self, val: u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn shst(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 12u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_shst(&mut self, val: u32) {
        let mask = 12u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn nssro(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_nssro(&mut self, val: u32) {
        let mask = 16u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn pp(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32u64 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pp(&mut self, val: u32) {
        let mask = 32u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967232u64 as u32;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 4294967232u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(rdy: u32, cfs: u32, shst: u32, nssro: u32, pp: u32,
                          reserved1: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((rdy as u32 as u32) << 0usize) &
                                          (1u64 as u32))
                             } |
                                 ((cfs as u32 as u32) << 1usize) &
                                     (2u64 as u32))
                        } | ((shst as u32 as u32) << 2usize) & (12u64 as u32))
                   } | ((nssro as u32 as u32) << 4usize) & (16u64 as u32))
              } | ((pp as u32 as u32) << 5usize) & (32u64 as u32))
         } | ((reserved1 as u32 as u32) << 6usize) & (4294967232u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_csts_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_csts_register>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_csts_register ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_csts_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_csts_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_csts_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_csts_register
                ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_csts_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_csts_register
                ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_csts_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_csts_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_shst_value {
    SPDK_NVME_SHST_NORMAL = 0,
    SPDK_NVME_SHST_OCCURRING = 1,
    SPDK_NVME_SHST_COMPLETE = 2,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_aqa_register {
    pub raw: u32,
    pub bits: spdk_nvme_aqa_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_aqa_register__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_aqa_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_aqa_register__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_aqa_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_aqa_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_aqa_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_aqa_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_aqa_register__bindgen_ty_1 {
    #[inline]
    pub fn asqs(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4095u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_asqs(&mut self, val: u32) {
        let mask = 4095u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 61440u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 61440u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn acqs(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 268369920u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_acqs(&mut self, val: u32) {
        let mask = 268369920u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4026531840u64 as u32;
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 4026531840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(asqs: u32, reserved1: u32, acqs: u32,
                          reserved2: u32) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((asqs as u32 as u32) << 0usize) &
                                (4095u64 as u32))
                   } |
                       ((reserved1 as u32 as u32) << 12usize) &
                           (61440u64 as u32))
              } | ((acqs as u32 as u32) << 16usize) & (268369920u64 as u32))
         } | ((reserved2 as u32 as u32) << 28usize) & (4026531840u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_aqa_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_aqa_register>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_aqa_register )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_aqa_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_aqa_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_aqa_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_aqa_register
                ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_aqa_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_aqa_register
                ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_aqa_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_aqa_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_vs_register {
    pub raw: u32,
    pub bits: spdk_nvme_vs_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_vs_register__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_vs_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_vs_register__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_vs_register__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_vs_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_vs_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_vs_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_vs_register__bindgen_ty_1 {
    #[inline]
    pub fn ter(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ter(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mnr(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mnr(&mut self, val: u32) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mjr(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294901760u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mjr(&mut self, val: u32) {
        let mask = 4294901760u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ter: u32, mnr: u32, mjr: u32) -> u32 {
        ({
             ({ ({ 0 } | ((ter as u32 as u32) << 0usize) & (255u64 as u32)) }
                  | ((mnr as u32 as u32) << 8usize) & (65280u64 as u32))
         } | ((mjr as u32 as u32) << 16usize) & (4294901760u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_vs_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_vs_register>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_vs_register )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_vs_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_vs_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_vs_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_vs_register )
                , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_vs_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_vs_register )
                , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_vs_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_vs_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cmbloc_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbloc_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cmbloc_register__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbloc_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmbloc_register__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_cmbloc_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmbloc_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cmbloc_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_cmbloc_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_cmbloc_register__bindgen_ty_1 {
    #[inline]
    pub fn bir(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 7u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bir(&mut self, val: u32) {
        let mask = 7u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4088u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 4088u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ofst(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294963200u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ofst(&mut self, val: u32) {
        let mask = 4294963200u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(bir: u32, reserved1: u32, ofst: u32) -> u32 {
        ({
             ({ ({ 0 } | ((bir as u32 as u32) << 0usize) & (7u64 as u32)) } |
                  ((reserved1 as u32 as u32) << 3usize) & (4088u64 as u32))
         } | ((ofst as u32 as u32) << 12usize) & (4294963200u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbloc_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmbloc_register>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cmbloc_register ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmbloc_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cmbloc_register )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmbloc_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmbloc_register ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmbloc_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmbloc_register ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_cmbloc_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cmbloc_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cmbsz_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbsz_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cmbsz_register__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsz_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmbsz_register__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_cmbsz_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmbsz_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cmbsz_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_cmbsz_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_cmbsz_register__bindgen_ty_1 {
    #[inline]
    pub fn sqs(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sqs(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn cqs(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_cqs(&mut self, val: u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn lists(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lists(&mut self, val: u32) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn rds(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rds(&mut self, val: u32) {
        let mask = 8u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn wds(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_wds(&mut self, val: u32) {
        let mask = 16u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 224u64 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 224u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn szu(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3840u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_szu(&mut self, val: u32) {
        let mask = 3840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn sz(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294963200u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sz(&mut self, val: u32) {
        let mask = 4294963200u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(sqs: u32, cqs: u32, lists: u32, rds: u32, wds: u32,
                          reserved1: u32, szu: u32, sz: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((sqs as u32 as u32) <<
                                                     0usize) & (1u64 as u32))
                                       } |
                                           ((cqs as u32 as u32) << 1usize) &
                                               (2u64 as u32))
                                  } |
                                      ((lists as u32 as u32) << 2usize) &
                                          (4u64 as u32))
                             } |
                                 ((rds as u32 as u32) << 3usize) &
                                     (8u64 as u32))
                        } | ((wds as u32 as u32) << 4usize) & (16u64 as u32))
                   } |
                       ((reserved1 as u32 as u32) << 5usize) &
                           (224u64 as u32))
              } | ((szu as u32 as u32) << 8usize) & (3840u64 as u32))
         } | ((sz as u32 as u32) << 12usize) & (4294963200u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsz_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmbsz_register>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cmbsz_register ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmbsz_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cmbsz_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmbsz_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmbsz_register ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmbsz_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmbsz_register ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_cmbsz_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cmbsz_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// Boot partition information
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_bpinfo_register {
    pub raw: u32,
    pub bits: spdk_nvme_bpinfo_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_bpinfo_register__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_bpinfo_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_bpinfo_register__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_bpinfo_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_bpinfo_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_bpinfo_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_bpinfo_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_bpinfo_register__bindgen_ty_1 {
    #[inline]
    pub fn bpsz(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32767u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bpsz(&mut self, val: u32) {
        let mask = 32767u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16744448u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 16744448u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn brs(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 50331648u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_brs(&mut self, val: u32) {
        let mask = 50331648u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2080374784u64 as u32;
        let val = (unit_field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 2080374784u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 26usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn abpid(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2147483648u64 as u32;
        let val = (unit_field_val & mask) >> 31usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_abpid(&mut self, val: u32) {
        let mask = 2147483648u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 31usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(bpsz: u32, reserved1: u32, brs: u32, reserved2: u32,
                          abpid: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((bpsz as u32 as u32) << 0usize) &
                                     (32767u64 as u32))
                        } |
                            ((reserved1 as u32 as u32) << 15usize) &
                                (16744448u64 as u32))
                   } |
                       ((brs as u32 as u32) << 24usize) &
                           (50331648u64 as u32))
              } |
                  ((reserved2 as u32 as u32) << 26usize) &
                      (2080374784u64 as u32))
         } | ((abpid as u32 as u32) << 31usize) & (2147483648u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_bpinfo_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_bpinfo_register>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_bpinfo_register ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_bpinfo_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_bpinfo_register )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_bpinfo_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_bpinfo_register ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_bpinfo_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_bpinfo_register ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_bpinfo_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_bpinfo_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// Boot partition read select
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_bprsel_register {
    pub raw: u32,
    pub bits: spdk_nvme_bprsel_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_bprsel_register__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_bprsel_register__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_bprsel_register__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_bprsel_register__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_bprsel_register__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_bprsel_register__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_bprsel_register__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_bprsel_register__bindgen_ty_1 {
    #[inline]
    pub fn bprsz(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1023u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bprsz(&mut self, val: u32) {
        let mask = 1023u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bprof(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1073740800u64 as u32;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bprof(&mut self, val: u32) {
        let mask = 1073740800u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1073741824u64 as u32;
        let val = (unit_field_val & mask) >> 30usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 1073741824u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 30usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bpid(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2147483648u64 as u32;
        let val = (unit_field_val & mask) >> 31usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bpid(&mut self, val: u32) {
        let mask = 2147483648u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 31usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(bprsz: u32, bprof: u32, reserved: u32, bpid: u32)
     -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((bprsz as u32 as u32) << 0usize) &
                                (1023u64 as u32))
                   } |
                       ((bprof as u32 as u32) << 10usize) &
                           (1073740800u64 as u32))
              } |
                  ((reserved as u32 as u32) << 30usize) &
                      (1073741824u64 as u32))
         } | ((bpid as u32 as u32) << 31usize) & (2147483648u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_bprsel_register() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_bprsel_register>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_bprsel_register ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_bprsel_register>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_bprsel_register )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_bprsel_register ) ) . raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_bprsel_register ) , "::" , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_bprsel_register ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_bprsel_register ) , "::" , stringify ! ( bits ) ));
}
impl Clone for spdk_nvme_bprsel_register {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_bprsel_register {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_registers {
    /// controller capabilities
    pub cap: spdk_nvme_cap_register,
    /// version of NVMe specification
    pub vs: spdk_nvme_vs_register,
    pub intms: u32,
    pub intmc: u32,
    /// controller configuration
    pub cc: spdk_nvme_cc_register,
    pub reserved1: u32,
    pub csts: spdk_nvme_csts_register,
    pub nssr: u32,
    /// admin queue attributes
    pub aqa: spdk_nvme_aqa_register,
    pub asq: u64,
    pub acq: u64,
    /// controller memory buffer location
    pub cmbloc: spdk_nvme_cmbloc_register,
    /// controller memory buffer size
    pub cmbsz: spdk_nvme_cmbsz_register,
    /// boot partition information
    pub bpinfo: spdk_nvme_bpinfo_register,
    /// boot partition read select
    pub bprsel: spdk_nvme_bprsel_register,
    /// boot partition memory buffer location (must be 4KB aligned)
    pub bpmbl: u64,
    pub reserved3: [u32; 1004usize],
    pub doorbell: [spdk_nvme_registers__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_registers__bindgen_ty_1 {
    pub sq_tdbl: u32,
    pub cq_hdbl: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_registers__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_registers__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_registers__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_registers__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_registers__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers__bindgen_ty_1 ) ) .
                sq_tdbl as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_registers__bindgen_ty_1 ) , "::" , stringify ! (
                sq_tdbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers__bindgen_ty_1 ) ) .
                cq_hdbl as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_registers__bindgen_ty_1 ) , "::" , stringify ! (
                cq_hdbl ) ));
}
impl Clone for spdk_nvme_registers__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_spdk_nvme_registers() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_registers>() , 4104usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_registers )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_registers>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_registers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . cap as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . vs as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( vs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . intms as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( intms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . intmc as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( intmc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . cc as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( cc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . reserved1 as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . csts as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( csts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . nssr as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( nssr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . aqa as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( aqa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . asq as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( asq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . acq as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( acq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . cmbloc as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( cmbloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . cmbsz as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( cmbsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . bpinfo as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( bpinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . bprsel as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( bprsel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . bpmbl as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( bpmbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . reserved3 as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_registers ) ) . doorbell as *
                const _ as usize } , 4096usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_registers ) ,
                "::" , stringify ! ( doorbell ) ));
}
impl Clone for spdk_nvme_registers {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_registers {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_sgl_descriptor_type {
    SPDK_NVME_SGL_TYPE_DATA_BLOCK = 0,
    SPDK_NVME_SGL_TYPE_BIT_BUCKET = 1,
    SPDK_NVME_SGL_TYPE_SEGMENT = 2,
    SPDK_NVME_SGL_TYPE_LAST_SEGMENT = 3,
    SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK = 4,
    SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_sgl_descriptor_subtype {
    SPDK_NVME_SGL_SUBTYPE_ADDRESS = 0,
    SPDK_NVME_SGL_SUBTYPE_OFFSET = 1,
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct spdk_nvme_sgl_descriptor {
    pub address: u64,
    pub __bindgen_anon_1: spdk_nvme_sgl_descriptor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    pub generic: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1,
    pub unkeyed: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2,
    pub keyed: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub reserved: [u8; 7usize],
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ) .
                reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( reserved ) ));
}
impl Clone for spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn subtype(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u8) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(subtype: u8, type_: u8) -> u8 {
        ({ ({ 0 } | ((subtype as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((type_ as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    pub length: u32,
    pub reserved: [u8; 3usize],
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ) .
                length as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ) .
                reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( reserved ) ));
}
impl Clone for spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn subtype(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u8) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(subtype: u8, type_: u8) -> u8 {
        ({ ({ 0 } | ((subtype as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((type_ as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_1: [u32; 2usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ) ));
}
impl Clone for spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn length(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16777215u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u64) {
        let mask = 16777215u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn key(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 72057594021150720u64 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_key(&mut self, val: u64) {
        let mask = 72057594021150720u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn subtype(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1080863910568919040u64 as u64;
        let val = (unit_field_val & mask) >> 56usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u64) {
        let mask = 1080863910568919040u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 56usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn type_(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 17293822569102704640u64 as u64;
        let val = (unit_field_val & mask) >> 60usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u64) {
        let mask = 17293822569102704640u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 60usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(length: u64, key: u64, subtype: u64, type_: u64)
     -> u64 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((length as u64 as u64) << 0usize) &
                                (16777215u64 as u64))
                   } |
                       ((key as u64 as u64) << 24usize) &
                           (72057594021150720u64 as u64))
              } |
                  ((subtype as u64 as u64) << 56usize) &
                      (1080863910568919040u64 as u64))
         } |
             ((type_ as u64 as u64) << 60usize) &
                 (17293822569102704640u64 as u64))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_sgl_descriptor__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_sgl_descriptor__bindgen_ty_1 )
                ) . generic as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1 ) , "::" , stringify !
                ( generic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_sgl_descriptor__bindgen_ty_1 )
                ) . unkeyed as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1 ) , "::" , stringify !
                ( unkeyed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_sgl_descriptor__bindgen_ty_1 )
                ) . keyed as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor__bindgen_ty_1 ) , "::" , stringify !
                ( keyed ) ));
}
impl Clone for spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_sgl_descriptor>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_sgl_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_sgl_descriptor ) ) . address as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_sgl_descriptor ) , "::" , stringify ! ( address )
                ));
}
impl Clone for spdk_nvme_sgl_descriptor {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_sgl_descriptor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_psdt_value {
    SPDK_NVME_PSDT_PRP = 0,
    SPDK_NVME_PSDT_SGL_MPTR_CONTIG = 1,
    SPDK_NVME_PSDT_SGL_MPTR_SGL = 2,
    SPDK_NVME_PSDT_RESERVED = 3,
}
#[repr(u32)]
/// Submission queue priority values for Create I/O Submission Queue Command.
///
/// Only valid for weighted round robin arbitration method.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_qprio {
    SPDK_NVME_QPRIO_URGENT = 0,
    SPDK_NVME_QPRIO_HIGH = 1,
    SPDK_NVME_QPRIO_MEDIUM = 2,
    SPDK_NVME_QPRIO_LOW = 3,
}
#[repr(u32)]
/// Optional Arbitration Mechanism Supported by the controller.
///
/// Two bits for CAP.AMS (18:17) field are set to '1' when the controller supports.
/// There is no bit for AMS_RR where all controllers support and set to 0x0 by default.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_cap_ams {
    SPDK_NVME_CAP_AMS_WRR = 1,
    SPDK_NVME_CAP_AMS_VS = 2,
}
#[repr(u32)]
/// Arbitration Mechanism Selected to the controller.
///
/// Value 0x2 to 0x6 is reserved.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_cc_ams {
    SPDK_NVME_CC_AMS_RR = 0,
    SPDK_NVME_CC_AMS_WRR = 1,
    SPDK_NVME_CC_AMS_VS = 7,
}
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_cmd {
    pub _bitfield_1: [u8; 2usize],
    pub cid: u16,
    pub nsid: u32,
    pub rsvd2: u32,
    pub rsvd3: u32,
    pub mptr: u64,
    pub dptr: spdk_nvme_cmd__bindgen_ty_1,
    pub cdw10: u32,
    pub cdw11: u32,
    pub cdw12: u32,
    pub cdw13: u32,
    pub cdw14: u32,
    pub cdw15: u32,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_cmd__bindgen_ty_1 {
    pub prp: spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1,
    pub sgl1: spdk_nvme_sgl_descriptor,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub prp1: u64,
    pub prp2: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) )
                . prp1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( prp1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) )
                . prp2 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( prp2 ) ));
}
impl Clone for spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd__bindgen_ty_1 ) ) . prp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1 ) , "::" , stringify ! ( prp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd__bindgen_ty_1 ) ) . sgl1 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_cmd__bindgen_ty_1 ) , "::" , stringify ! ( sgl1 )
                ));
}
impl Clone for spdk_nvme_cmd__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cmd__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cmd>() , 64usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cmd ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cmd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cid as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . nsid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( nsid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . rsvd2 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( rsvd2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . rsvd3 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( rsvd3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . mptr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( mptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . dptr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( dptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw10 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw11 as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw12 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw13 as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw14 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cmd ) ) . cdw15 as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cmd ) , "::"
                , stringify ! ( cdw15 ) ));
}
impl Clone for spdk_nvme_cmd {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_cmd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl spdk_nvme_cmd {
    #[inline]
    pub fn opc(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 255u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: u16) {
        let mask = 255u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn fuse(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 768u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_fuse(&mut self, val: u16) {
        let mask = 768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 15360u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u16) {
        let mask = 15360u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn psdt(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 49152u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_psdt(&mut self, val: u16) {
        let mask = 49152u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(opc: u16, fuse: u16, rsvd1: u16, psdt: u16) -> u16 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((opc as u16 as u16) << 0usize) & (255u64 as u16))
                   } | ((fuse as u16 as u16) << 8usize) & (768u64 as u16))
              } | ((rsvd1 as u16 as u16) << 10usize) & (15360u64 as u16))
         } | ((psdt as u16 as u16) << 14usize) & (49152u64 as u16))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_status {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_status() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_status>() , 2usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_status ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_status>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( spdk_nvme_status ) ));
}
impl Clone for spdk_nvme_status {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_status {
    #[inline]
    pub fn p(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn sc(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 510u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_sc(&mut self, val: u16) {
        let mask = 510u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn sct(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 3584u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_sct(&mut self, val: u16) {
        let mask = 3584u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 12288u64 as u16;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u16) {
        let mask = 12288u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn m(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16384u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_m(&mut self, val: u16) {
        let mask = 16384u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn dnr(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_dnr(&mut self, val: u16) {
        let mask = 32768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(p: u16, sc: u16, sct: u16, rsvd2: u16, m: u16,
                          dnr: u16) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((p as u16 as u16) << 0usize) &
                                          (1u64 as u16))
                             } |
                                 ((sc as u16 as u16) << 1usize) &
                                     (510u64 as u16))
                        } |
                            ((sct as u16 as u16) << 9usize) &
                                (3584u64 as u16))
                   } | ((rsvd2 as u16 as u16) << 12usize) & (12288u64 as u16))
              } | ((m as u16 as u16) << 14usize) & (16384u64 as u16))
         } | ((dnr as u16 as u16) << 15usize) & (32768u64 as u16))
    }
}
/// Completion queue entry
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_cpl {
    pub cdw0: u32,
    pub rsvd1: u32,
    pub sqhd: u16,
    pub sqid: u16,
    pub cid: u16,
    pub status: spdk_nvme_status,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cpl() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_cpl>() , 16usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_cpl ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_cpl>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_cpl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . cdw0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( cdw0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . rsvd1 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( rsvd1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . sqhd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( sqhd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . sqid as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( sqid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . cid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( cid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_cpl ) ) . status as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_cpl ) , "::"
                , stringify ! ( status ) ));
}
impl Clone for spdk_nvme_cpl {
    fn clone(&self) -> Self { *self }
}
/// Dataset Management range
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_dsm_range {
    pub attributes: spdk_nvme_dsm_range__bindgen_ty_1,
    pub length: u32,
    pub starting_lba: u64,
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_dsm_range__bindgen_ty_1 {
    pub bits: spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1,
    pub raw: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn af(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 15u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_af(&mut self, val: u32) {
        let mask = 15u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn al(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 48u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_al(&mut self, val: u32) {
        let mask = 48u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 192u64 as u32;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        let mask = 192u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn sr(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 256u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sr(&mut self, val: u32) {
        let mask = 256u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn sw(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 512u64 as u32;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sw(&mut self, val: u32) {
        let mask = 512u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn wp(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1024u64 as u32;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_wp(&mut self, val: u32) {
        let mask = 1024u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16775168u64 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 16775168u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn access_size(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_access_size(&mut self, val: u32) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(af: u32, al: u32, reserved0: u32, sr: u32, sw: u32,
                          wp: u32, reserved1: u32, access_size: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((af as u32 as u32) << 0usize)
                                                    & (15u64 as u32))
                                       } |
                                           ((al as u32 as u32) << 4usize) &
                                               (48u64 as u32))
                                  } |
                                      ((reserved0 as u32 as u32) << 6usize) &
                                          (192u64 as u32))
                             } |
                                 ((sr as u32 as u32) << 8usize) &
                                     (256u64 as u32))
                        } | ((sw as u32 as u32) << 9usize) & (512u64 as u32))
                   } | ((wp as u32 as u32) << 10usize) & (1024u64 as u32))
              } |
                  ((reserved1 as u32 as u32) << 11usize) &
                      (16775168u64 as u32))
         } |
             ((access_size as u32 as u32) << 24usize) &
                 (4278190080u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_dsm_range__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_dsm_range__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_dsm_range__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range__bindgen_ty_1 ) ) .
                bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_dsm_range__bindgen_ty_1 ) , "::" , stringify ! (
                bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range__bindgen_ty_1 ) ) .
                raw as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_dsm_range__bindgen_ty_1 ) , "::" , stringify ! ( raw
                ) ));
}
impl Clone for spdk_nvme_dsm_range__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_dsm_range__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_dsm_range>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_dsm_range ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_dsm_range>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_dsm_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range ) ) . attributes as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_dsm_range ) ,
                "::" , stringify ! ( attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_dsm_range ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_dsm_range ) ) . starting_lba as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_dsm_range ) ,
                "::" , stringify ! ( starting_lba ) ));
}
impl Clone for spdk_nvme_dsm_range {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_dsm_range {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/// Status code types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_status_code_type {
    SPDK_NVME_SCT_GENERIC = 0,
    SPDK_NVME_SCT_COMMAND_SPECIFIC = 1,
    SPDK_NVME_SCT_MEDIA_ERROR = 2,
    SPDK_NVME_SCT_VENDOR_SPECIFIC = 7,
}
#[repr(u32)]
/// Generic command status codes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_generic_command_status_code {
    SPDK_NVME_SC_SUCCESS = 0,
    SPDK_NVME_SC_INVALID_OPCODE = 1,
    SPDK_NVME_SC_INVALID_FIELD = 2,
    SPDK_NVME_SC_COMMAND_ID_CONFLICT = 3,
    SPDK_NVME_SC_DATA_TRANSFER_ERROR = 4,
    SPDK_NVME_SC_ABORTED_POWER_LOSS = 5,
    SPDK_NVME_SC_INTERNAL_DEVICE_ERROR = 6,
    SPDK_NVME_SC_ABORTED_BY_REQUEST = 7,
    SPDK_NVME_SC_ABORTED_SQ_DELETION = 8,
    SPDK_NVME_SC_ABORTED_FAILED_FUSED = 9,
    SPDK_NVME_SC_ABORTED_MISSING_FUSED = 10,
    SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT = 11,
    SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR = 12,
    SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR = 13,
    SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS = 14,
    SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID = 15,
    SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID = 16,
    SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID = 17,
    SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF = 18,
    SPDK_NVME_SC_INVALID_PRP_OFFSET = 19,
    SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED = 20,
    SPDK_NVME_SC_OPERATION_DENIED = 21,
    SPDK_NVME_SC_INVALID_SGL_OFFSET = 22,
    SPDK_NVME_SC_INVALID_SGL_SUBTYPE = 23,
    SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT = 24,
    SPDK_NVME_SC_KEEP_ALIVE_EXPIRED = 25,
    SPDK_NVME_SC_KEEP_ALIVE_INVALID = 26,
    SPDK_NVME_SC_ABORTED_PREEMPT = 27,
    SPDK_NVME_SC_SANITIZE_FAILED = 28,
    SPDK_NVME_SC_SANITIZE_IN_PROGRESS = 29,
    SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID = 30,
    SPDK_NVME_SC_COMMAND_INVALID_IN_CMB = 31,
    SPDK_NVME_SC_LBA_OUT_OF_RANGE = 128,
    SPDK_NVME_SC_CAPACITY_EXCEEDED = 129,
    SPDK_NVME_SC_NAMESPACE_NOT_READY = 130,
    SPDK_NVME_SC_RESERVATION_CONFLICT = 131,
    SPDK_NVME_SC_FORMAT_IN_PROGRESS = 132,
}
#[repr(u32)]
/// Command specific status codes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_command_specific_status_code {
    SPDK_NVME_SC_COMPLETION_QUEUE_INVALID = 0,
    SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER = 1,
    SPDK_NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED = 2,
    SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED = 3,
    SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED = 5,
    SPDK_NVME_SC_INVALID_FIRMWARE_SLOT = 6,
    SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE = 7,
    SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR = 8,
    SPDK_NVME_SC_INVALID_LOG_PAGE = 9,
    SPDK_NVME_SC_INVALID_FORMAT = 10,
    SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET = 11,
    SPDK_NVME_SC_INVALID_QUEUE_DELETION = 12,
    SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE = 13,
    SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE = 14,
    SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC = 15,
    SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET = 16,
    SPDK_NVME_SC_FIRMWARE_REQ_RESET = 17,
    SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION = 18,
    SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED = 19,
    SPDK_NVME_SC_OVERLAPPING_RANGE = 20,
    SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY = 21,
    SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE = 22,
    SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED = 24,
    SPDK_NVME_SC_NAMESPACE_IS_PRIVATE = 25,
    SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED = 26,
    SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED = 27,
    SPDK_NVME_SC_CONTROLLER_LIST_INVALID = 28,
    SPDK_NVME_SC_DEVICE_SELF_TEST_IN_PROGRESS = 29,
    SPDK_NVME_SC_BOOT_PARTITION_WRITE_PROHIBITED = 30,
    SPDK_NVME_SC_INVALID_CTRLR_ID = 31,
    SPDK_NVME_SC_INVALID_SECONDARY_CTRLR_STATE = 32,
    SPDK_NVME_SC_INVALID_NUM_CTRLR_RESOURCES = 33,
    SPDK_NVME_SC_INVALID_RESOURCE_ID = 34,
    SPDK_NVME_SC_CONFLICTING_ATTRIBUTES = 128,
    SPDK_NVME_SC_INVALID_PROTECTION_INFO = 129,
    SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE = 130,
}
#[repr(u32)]
/// Media error status codes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_media_error_status_code {
    SPDK_NVME_SC_WRITE_FAULTS = 128,
    SPDK_NVME_SC_UNRECOVERED_READ_ERROR = 129,
    SPDK_NVME_SC_GUARD_CHECK_ERROR = 130,
    SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR = 131,
    SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR = 132,
    SPDK_NVME_SC_COMPARE_FAILURE = 133,
    SPDK_NVME_SC_ACCESS_DENIED = 134,
    SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK = 135,
}
#[repr(u32)]
/// Admin opcodes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_admin_opcode {
    SPDK_NVME_OPC_DELETE_IO_SQ = 0,
    SPDK_NVME_OPC_CREATE_IO_SQ = 1,
    SPDK_NVME_OPC_GET_LOG_PAGE = 2,
    SPDK_NVME_OPC_DELETE_IO_CQ = 4,
    SPDK_NVME_OPC_CREATE_IO_CQ = 5,
    SPDK_NVME_OPC_IDENTIFY = 6,
    SPDK_NVME_OPC_ABORT = 8,
    SPDK_NVME_OPC_SET_FEATURES = 9,
    SPDK_NVME_OPC_GET_FEATURES = 10,
    SPDK_NVME_OPC_ASYNC_EVENT_REQUEST = 12,
    SPDK_NVME_OPC_NS_MANAGEMENT = 13,
    SPDK_NVME_OPC_FIRMWARE_COMMIT = 16,
    SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD = 17,
    SPDK_NVME_OPC_DEVICE_SELF_TEST = 20,
    SPDK_NVME_OPC_NS_ATTACHMENT = 21,
    SPDK_NVME_OPC_KEEP_ALIVE = 24,
    SPDK_NVME_OPC_DIRECTIVE_SEND = 25,
    SPDK_NVME_OPC_DIRECTIVE_RECEIVE = 26,
    SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT = 28,
    SPDK_NVME_OPC_NVME_MI_SEND = 29,
    SPDK_NVME_OPC_NVME_MI_RECEIVE = 30,
    SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG = 124,
    SPDK_NVME_OPC_FORMAT_NVM = 128,
    SPDK_NVME_OPC_SECURITY_SEND = 129,
    SPDK_NVME_OPC_SECURITY_RECEIVE = 130,
    SPDK_NVME_OPC_SANITIZE = 132,
}
#[repr(u32)]
/// NVM command set opcodes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_nvm_opcode {
    SPDK_NVME_OPC_FLUSH = 0,
    SPDK_NVME_OPC_WRITE = 1,
    SPDK_NVME_OPC_READ = 2,
    SPDK_NVME_OPC_WRITE_UNCORRECTABLE = 4,
    SPDK_NVME_OPC_COMPARE = 5,
    SPDK_NVME_OPC_WRITE_ZEROES = 8,
    SPDK_NVME_OPC_DATASET_MANAGEMENT = 9,
    SPDK_NVME_OPC_RESERVATION_REGISTER = 13,
    SPDK_NVME_OPC_RESERVATION_REPORT = 14,
    SPDK_NVME_OPC_RESERVATION_ACQUIRE = 17,
    SPDK_NVME_OPC_RESERVATION_RELEASE = 21,
}
#[repr(u32)]
/// Data transfer (bits 1:0) of an NVMe opcode.
///
/// \sa spdk_nvme_opc_get_data_transfer
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_data_transfer {
    SPDK_NVME_DATA_NONE = 0,
    SPDK_NVME_DATA_HOST_TO_CONTROLLER = 1,
    SPDK_NVME_DATA_CONTROLLER_TO_HOST = 2,
    SPDK_NVME_DATA_BIDIRECTIONAL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_feat {
    SPDK_NVME_FEAT_ARBITRATION = 1,
    SPDK_NVME_FEAT_POWER_MANAGEMENT = 2,
    SPDK_NVME_FEAT_LBA_RANGE_TYPE = 3,
    SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD = 4,
    SPDK_NVME_FEAT_ERROR_RECOVERY = 5,
    SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE = 6,
    SPDK_NVME_FEAT_NUMBER_OF_QUEUES = 7,
    SPDK_NVME_FEAT_INTERRUPT_COALESCING = 8,
    SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION = 9,
    SPDK_NVME_FEAT_WRITE_ATOMICITY = 10,
    SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION = 11,
    SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION = 12,
    SPDK_NVME_FEAT_HOST_MEM_BUFFER = 13,
    SPDK_NVME_FEAT_TIMESTAMP = 14,
    SPDK_NVME_FEAT_KEEP_ALIVE_TIMER = 15,
    SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT = 16,
    SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG = 17,
    SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER = 128,
    SPDK_NVME_FEAT_HOST_IDENTIFIER = 129,
    SPDK_NVME_FEAT_HOST_RESERVE_MASK = 130,
    SPDK_NVME_FEAT_HOST_RESERVE_PERSIST = 131,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_dsm_attribute {
    SPDK_NVME_DSM_ATTR_INTEGRAL_READ = 1,
    SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE = 2,
    SPDK_NVME_DSM_ATTR_DEALLOCATE = 4,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_power_state {
    pub mp: u16,
    pub reserved1: u8,
    pub _bitfield_1: u8,
    pub enlat: u32,
    pub exlat: u32,
    pub _bitfield_2: [u8; 4usize],
    pub reserved7: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_power_state() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_power_state>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_power_state )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_power_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_power_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . mp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( mp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . reserved1 as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . enlat as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( enlat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . exlat as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( exlat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_power_state ) ) . reserved7 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_power_state )
                , "::" , stringify ! ( reserved7 ) ));
}
impl Clone for spdk_nvme_power_state {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_power_state {
    #[inline]
    pub fn mps(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn nops(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_nops(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 252u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        let mask = 252u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(mps: u8, nops: u8, reserved2: u8) -> u8 {
        ({
             ({ ({ 0 } | ((mps as u8 as u8) << 0usize) & (1u64 as u8)) } |
                  ((nops as u8 as u8) << 1usize) & (2u64 as u8))
         } | ((reserved2 as u8 as u8) << 2usize) & (252u64 as u8))
    }
    #[inline]
    pub fn rrt(&self) -> u8 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 31u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rrt(&mut self, val: u8) {
        let mask = 31u64 as u32;
        let val = val as u8 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 224u64 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        let mask = 224u64 as u32;
        let val = val as u8 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn rrl(&self) -> u8 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 7936u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rrl(&mut self, val: u8) {
        let mask = 7936u64 as u32;
        let val = val as u8 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u8 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 57344u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u8) {
        let mask = 57344u64 as u32;
        let val = val as u8 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn rwt(&self) -> u8 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2031616u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rwt(&mut self, val: u8) {
        let mask = 2031616u64 as u32;
        let val = val as u8 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u8 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 14680064u64 as u32;
        let val = (unit_field_val & mask) >> 21usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u8) {
        let mask = 14680064u64 as u32;
        let val = val as u8 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 21usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn rwl(&self) -> u8 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 520093696u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rwl(&mut self, val: u8) {
        let mask = 520093696u64 as u32;
        let val = val as u8 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u8 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3758096384u64 as u32;
        let val = (unit_field_val & mask) >> 29usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u8) {
        let mask = 3758096384u64 as u32;
        let val = val as u8 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 29usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_2(rrt: u8, reserved3: u8, rrl: u8, reserved4: u8,
                          rwt: u8, reserved5: u8, rwl: u8, reserved6: u8)
     -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((rrt as u8 as u32) << 0usize)
                                                    & (31u64 as u32))
                                       } |
                                           ((reserved3 as u8 as u32) <<
                                                5usize) & (224u64 as u32))
                                  } |
                                      ((rrl as u8 as u32) << 8usize) &
                                          (7936u64 as u32))
                             } |
                                 ((reserved4 as u8 as u32) << 13usize) &
                                     (57344u64 as u32))
                        } |
                            ((rwt as u8 as u32) << 16usize) &
                                (2031616u64 as u32))
                   } |
                       ((reserved5 as u8 as u32) << 21usize) &
                           (14680064u64 as u32))
              } | ((rwl as u8 as u32) << 24usize) & (520093696u64 as u32))
         } | ((reserved6 as u8 as u32) << 29usize) & (3758096384u64 as u32))
    }
}
#[repr(u32)]
/// Identify command CNS value
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_identify_cns {
    SPDK_NVME_IDENTIFY_NS = 0,
    SPDK_NVME_IDENTIFY_CTRLR = 1,
    SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST = 2,
    SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST = 3,
    SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST = 16,
    SPDK_NVME_IDENTIFY_NS_ALLOCATED = 17,
    SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST = 18,
    SPDK_NVME_IDENTIFY_CTRLR_LIST = 19,
    SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP = 20,
    SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST = 21,
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct spdk_nvme_ctrlr_data {
    /// pci vendor id
    pub vid: u16,
    /// pci subsystem vendor id
    pub ssvid: u16,
    /// serial number
    pub sn: [i8; 20usize],
    /// model number
    pub mn: [i8; 40usize],
    /// firmware revision
    pub fr: [u8; 8usize],
    /// recommended arbitration burst
    pub rab: u8,
    /// ieee oui identifier
    pub ieee: [u8; 3usize],
    pub cmic: spdk_nvme_ctrlr_data__bindgen_ty_1,
    /// maximum data transfer size
    pub mdts: u8,
    /// controller id
    pub cntlid: u16,
    /// version
    pub ver: spdk_nvme_vs_register,
    /// RTD3 resume latency
    pub rtd3r: u32,
    /// RTD3 entry latency
    pub rtd3e: u32,
    pub oaes: spdk_nvme_ctrlr_data__bindgen_ty_2,
    pub ctratt: spdk_nvme_ctrlr_data__bindgen_ty_3,
    pub reserved_100: [u8; 12usize],
    /// FRU globally unique identifier
    pub fguid: [u8; 16usize],
    pub reserved_128: [u8; 128usize],
    pub oacs: spdk_nvme_ctrlr_data__bindgen_ty_4,
    /// abort command limit
    pub acl: u8,
    /// asynchronous event request limit
    pub aerl: u8,
    pub frmw: spdk_nvme_ctrlr_data__bindgen_ty_5,
    pub lpa: spdk_nvme_ctrlr_data__bindgen_ty_6,
    /// error log page entries
    pub elpe: u8,
    /// number of power states supported
    pub npss: u8,
    pub avscc: spdk_nvme_ctrlr_data__bindgen_ty_7,
    pub apsta: spdk_nvme_ctrlr_data__bindgen_ty_8,
    /// warning composite temperature threshold
    pub wctemp: u16,
    /// critical composite temperature threshold
    pub cctemp: u16,
    /// maximum time for firmware activation
    pub mtfa: u16,
    /// host memory buffer preferred size
    pub hmpre: u32,
    /// host memory buffer minimum size
    pub hmmin: u32,
    /// total NVM capacity
    pub tnvmcap: [u64; 2usize],
    /// unallocated NVM capacity
    pub unvmcap: [u64; 2usize],
    pub rpmbs: spdk_nvme_ctrlr_data__bindgen_ty_9,
    /// extended device self-test time (in minutes)
    pub edstt: u16,
    pub dsto: spdk_nvme_ctrlr_data__bindgen_ty_10,
    /// Firmware update granularity
    ///
    /// 4KB units
    /// 0x00 = no information provided
    /// 0xFF = no restriction
    pub fwug: u8,
    /// Keep Alive Support
    ///
    /// Granularity of keep alive timer in 100 ms units
    /// 0 = keep alive not supported
    pub kas: u16,
    pub hctma: spdk_nvme_ctrlr_data__bindgen_ty_11,
    /// Minimum thermal management temperature
    pub mntmt: u16,
    /// Maximum thermal management temperature
    pub mxtmt: u16,
    pub sanicap: spdk_nvme_ctrlr_data__bindgen_ty_12,
    pub reserved3: [u8; 180usize],
    pub sqes: spdk_nvme_ctrlr_data__bindgen_ty_13,
    pub cqes: spdk_nvme_ctrlr_data__bindgen_ty_14,
    pub maxcmd: u16,
    /// number of namespaces
    pub nn: u32,
    pub oncs: spdk_nvme_ctrlr_data__bindgen_ty_15,
    /// fused operation support
    pub fuses: u16,
    pub fna: spdk_nvme_ctrlr_data__bindgen_ty_16,
    pub vwc: spdk_nvme_ctrlr_data__bindgen_ty_17,
    /// atomic write unit normal
    pub awun: u16,
    /// atomic write unit power fail
    pub awupf: u16,
    /// NVM vendor specific command configuration
    pub nvscc: u8,
    pub reserved531: u8,
    /// atomic compare & write unit
    pub acwu: u16,
    pub reserved534: u16,
    pub sgls: spdk_nvme_ctrlr_data__bindgen_ty_18,
    pub reserved4: [u8; 228usize],
    pub subnqn: [u8; 256usize],
    pub reserved5: [u8; 768usize],
    pub nvmf_specific: spdk_nvme_ctrlr_data__bindgen_ty_19,
    pub psd: [spdk_nvme_power_state; 32usize],
    pub vs: [u8; 1024usize],
}
/// controller multi-path I/O and namespace sharing capabilities
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_1>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_1 {
    #[inline]
    pub fn multi_port(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_multi_port(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn multi_host(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_multi_host(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn sr_iov(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_sr_iov(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 248u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 248u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(multi_port: u8, multi_host: u8, sr_iov: u8,
                          reserved: u8) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((multi_port as u8 as u8) << 0usize) &
                                (1u64 as u8))
                   } | ((multi_host as u8 as u8) << 1usize) & (2u64 as u8))
              } | ((sr_iov as u8 as u8) << 2usize) & (4u64 as u8))
         } | ((reserved as u8 as u8) << 3usize) & (248u64 as u8))
    }
}
/// optional asynchronous events supported
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_2 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_2>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_2 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_2 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ns_attribute_notices(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 256u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ns_attribute_notices(&mut self, val: u32) {
        let mask = 256u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn fw_activation_notices(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 512u64 as u32;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_fw_activation_notices(&mut self, val: u32) {
        let mask = 512u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294966272u64 as u32;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 4294966272u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved1: u32, ns_attribute_notices: u32,
                          fw_activation_notices: u32, reserved2: u32) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((reserved1 as u32 as u32) << 0usize) &
                                (255u64 as u32))
                   } |
                       ((ns_attribute_notices as u32 as u32) << 8usize) &
                           (256u64 as u32))
              } |
                  ((fw_activation_notices as u32 as u32) << 9usize) &
                      (512u64 as u32))
         } | ((reserved2 as u32 as u32) << 10usize) & (4294966272u64 as u32))
    }
}
/// controller attributes
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_3 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_3>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_3
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_3>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_3 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_3 {
    #[inline]
    pub fn host_id_exhid_supported(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_host_id_exhid_supported(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn non_operational_power_state_permissive_mode(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_non_operational_power_state_permissive_mode(&mut self,
                                                           val: u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967292u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967292u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(host_id_exhid_supported: u32,
                          non_operational_power_state_permissive_mode: u32,
                          reserved: u32) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((host_id_exhid_supported as u32 as u32) << 0usize) &
                           (1u64 as u32))
              } |
                  ((non_operational_power_state_permissive_mode as u32 as u32)
                       << 1usize) & (2u64 as u32))
         } | ((reserved as u32 as u32) << 2usize) & (4294967292u64 as u32))
    }
}
/// optional admin command support
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_4 {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_4>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_4
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_4>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_4 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_4 {
    #[inline]
    pub fn security(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_security(&mut self, val: u16) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn format(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_format(&mut self, val: u16) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn firmware(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_firmware(&mut self, val: u16) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ns_manage(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_ns_manage(&mut self, val: u16) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn device_self_test(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_device_self_test(&mut self, val: u16) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn directives(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_directives(&mut self, val: u16) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn nvme_mi(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_nvme_mi(&mut self, val: u16) {
        let mask = 64u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn virtualization_management(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_virtualization_management(&mut self, val: u16) {
        let mask = 128u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn doorbell_buffer_config(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_doorbell_buffer_config(&mut self, val: u16) {
        let mask = 256u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn oacs_rsvd(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 65024u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_oacs_rsvd(&mut self, val: u16) {
        let mask = 65024u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(security: u16, format: u16, firmware: u16,
                          ns_manage: u16, device_self_test: u16,
                          directives: u16, nvme_mi: u16,
                          virtualization_management: u16,
                          doorbell_buffer_config: u16, oacs_rsvd: u16)
     -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({ 0 } |
                                                          ((security as u16 as
                                                                u16) <<
                                                               0usize) &
                                                              (1u64 as u16))
                                                 } |
                                                     ((format as u16 as u16)
                                                          << 1usize) &
                                                         (2u64 as u16))
                                            } |
                                                ((firmware as u16 as u16) <<
                                                     2usize) & (4u64 as u16))
                                       } |
                                           ((ns_manage as u16 as u16) <<
                                                3usize) & (8u64 as u16))
                                  } |
                                      ((device_self_test as u16 as u16) <<
                                           4usize) & (16u64 as u16))
                             } |
                                 ((directives as u16 as u16) << 5usize) &
                                     (32u64 as u16))
                        } |
                            ((nvme_mi as u16 as u16) << 6usize) &
                                (64u64 as u16))
                   } |
                       ((virtualization_management as u16 as u16) << 7usize) &
                           (128u64 as u16))
              } |
                  ((doorbell_buffer_config as u16 as u16) << 8usize) &
                      (256u64 as u16))
         } | ((oacs_rsvd as u16 as u16) << 9usize) & (65024u64 as u16))
    }
}
/// firmware updates
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_5 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_5>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_5
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_5>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_5 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_5 {
    #[inline]
    pub fn slot1_ro(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_slot1_ro(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn num_slots(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 14u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_num_slots(&mut self, val: u8) {
        let mask = 14u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn activation_without_reset(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_activation_without_reset(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn frmw_rsvd(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 224u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_frmw_rsvd(&mut self, val: u8) {
        let mask = 224u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(slot1_ro: u8, num_slots: u8,
                          activation_without_reset: u8, frmw_rsvd: u8) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((slot1_ro as u8 as u8) << 0usize) & (1u64 as u8))
                   } | ((num_slots as u8 as u8) << 1usize) & (14u64 as u8))
              } |
                  ((activation_without_reset as u8 as u8) << 4usize) &
                      (16u64 as u8))
         } | ((frmw_rsvd as u8 as u8) << 5usize) & (224u64 as u8))
    }
}
/// log page attributes
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_6 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_6>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_6
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_6>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_6 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_6 {
    #[inline]
    pub fn ns_smart(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ns_smart(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn celp(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_celp(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn edlp(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_edlp(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn telemetry(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_telemetry(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn lpa_rsvd(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_lpa_rsvd(&mut self, val: u8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ns_smart: u8, celp: u8, edlp: u8, telemetry: u8,
                          lpa_rsvd: u8) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((ns_smart as u8 as u8) << 0usize) &
                                     (1u64 as u8))
                        } | ((celp as u8 as u8) << 1usize) & (2u64 as u8))
                   } | ((edlp as u8 as u8) << 2usize) & (4u64 as u8))
              } | ((telemetry as u8 as u8) << 3usize) & (8u64 as u8))
         } | ((lpa_rsvd as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
/// admin vendor specific command configuration
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_7 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_7>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_7
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_7>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_7 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_7 {
    #[inline]
    pub fn spec_format(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_spec_format(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn avscc_rsvd(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 254u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_avscc_rsvd(&mut self, val: u8) {
        let mask = 254u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(spec_format: u8, avscc_rsvd: u8) -> u8 {
        ({ ({ 0 } | ((spec_format as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((avscc_rsvd as u8 as u8) << 1usize) & (254u64 as u8))
    }
}
/// autonomous power state transition attributes
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_8 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_8>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_8
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_8>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_8 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_8 {
    #[inline]
    pub fn supported(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn apsta_rsvd(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 254u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_apsta_rsvd(&mut self, val: u8) {
        let mask = 254u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(supported: u8, apsta_rsvd: u8) -> u8 {
        ({ ({ 0 } | ((supported as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((apsta_rsvd as u8 as u8) << 1usize) & (254u64 as u8))
    }
}
/// replay protected memory block support
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_9 {
    pub _bitfield_1: u8,
    pub reserved2: u8,
    pub total_size: u8,
    pub access_size: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_9>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_9
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_9>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) .
                reserved2 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_9 ) , "::" , stringify ! (
                reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) .
                total_size as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_9 ) , "::" , stringify ! (
                total_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) .
                access_size as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_9 ) , "::" , stringify ! (
                access_size ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_9 {
    #[inline]
    pub fn num_rpmb_units(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 7u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_num_rpmb_units(&mut self, val: u8) {
        let mask = 7u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn auth_method(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 56u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_auth_method(&mut self, val: u8) {
        let mask = 56u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 192u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        let mask = 192u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(num_rpmb_units: u8, auth_method: u8, reserved1: u8)
     -> u8 {
        ({
             ({
                  ({ 0 } |
                       ((num_rpmb_units as u8 as u8) << 0usize) &
                           (7u64 as u8))
              } | ((auth_method as u8 as u8) << 3usize) & (56u64 as u8))
         } | ((reserved1 as u8 as u8) << 6usize) & (192u64 as u8))
    }
}
/// device self-test options
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_10 {
    pub raw: u8,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn one_only(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_one_only(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 254u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 254u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(one_only: u8, reserved: u8) -> u8 {
        ({ ({ 0 } | ((one_only as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((reserved as u8 as u8) << 1usize) & (254u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_10>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_10>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_10 ) ) .
                raw as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_10 ) , "::" , stringify ! (
                raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_10 ) ) .
                bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_10 ) , "::" , stringify ! (
                bits ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// Host controlled thermal management attributes
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_11 {
    pub raw: u16,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: u16,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1>()
               , 2usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn supported(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u16) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 65534u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        let mask = 65534u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(supported: u16, reserved: u16) -> u16 {
        ({ ({ 0 } | ((supported as u16 as u16) << 0usize) & (1u64 as u16)) } |
             ((reserved as u16 as u16) << 1usize) & (65534u64 as u16))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_11>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_11>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_11 ) ) .
                raw as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_11 ) , "::" , stringify ! (
                raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_11 ) ) .
                bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_11 ) , "::" , stringify ! (
                bits ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// Sanitize capabilities
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_12 {
    pub raw: u32,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn crypto_erase(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_crypto_erase(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn block_erase(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_block_erase(&mut self, val: u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn overwrite(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_overwrite(&mut self, val: u32) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967288u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(crypto_erase: u32, block_erase: u32, overwrite: u32,
                          reserved: u32) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((crypto_erase as u32 as u32) << 0usize) &
                                (1u64 as u32))
                   } |
                       ((block_erase as u32 as u32) << 1usize) &
                           (2u64 as u32))
              } | ((overwrite as u32 as u32) << 2usize) & (4u64 as u32))
         } | ((reserved as u32 as u32) << 3usize) & (4294967288u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_12>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_12>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_12 ) ) .
                raw as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_12 ) , "::" , stringify ! (
                raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_12 ) ) .
                bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_12 ) , "::" , stringify ! (
                bits ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// submission queue entry size
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_13 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_13>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_13
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_13>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_13 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_13 {
    #[inline]
    pub fn min(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_min(&mut self, val: u8) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn max(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(min: u8, max: u8) -> u8 {
        ({ ({ 0 } | ((min as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((max as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
/// completion queue entry size
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_14 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_14>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_14
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_14>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_14 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_14 {
    #[inline]
    pub fn min(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_min(&mut self, val: u8) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn max(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(min: u8, max: u8) -> u8 {
        ({ ({ 0 } | ((min as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((max as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
/// optional nvm command support
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_15 {
    pub _bitfield_1: u16,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_15>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_15
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_15>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_15 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_15 {
    #[inline]
    pub fn compare(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_compare(&mut self, val: u16) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn write_unc(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_write_unc(&mut self, val: u16) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn dsm(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_dsm(&mut self, val: u16) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn write_zeroes(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_write_zeroes(&mut self, val: u16) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn set_features_save(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_set_features_save(&mut self, val: u16) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn reservations(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_reservations(&mut self, val: u16) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn timestamp(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: u16) {
        let mask = 64u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 65408u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        let mask = 65408u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(compare: u16, write_unc: u16, dsm: u16,
                          write_zeroes: u16, set_features_save: u16,
                          reservations: u16, timestamp: u16, reserved: u16)
     -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((compare as u16 as u16) <<
                                                     0usize) & (1u64 as u16))
                                       } |
                                           ((write_unc as u16 as u16) <<
                                                1usize) & (2u64 as u16))
                                  } |
                                      ((dsm as u16 as u16) << 2usize) &
                                          (4u64 as u16))
                             } |
                                 ((write_zeroes as u16 as u16) << 3usize) &
                                     (8u64 as u16))
                        } |
                            ((set_features_save as u16 as u16) << 4usize) &
                                (16u64 as u16))
                   } |
                       ((reservations as u16 as u16) << 5usize) &
                           (32u64 as u16))
              } | ((timestamp as u16 as u16) << 6usize) & (64u64 as u16))
         } | ((reserved as u16 as u16) << 7usize) & (65408u64 as u16))
    }
}
/// format nvm attributes
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_16 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_16>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_16
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_16>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_16 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_16 {
    #[inline]
    pub fn format_all_ns(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_format_all_ns(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn erase_all_ns(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_erase_all_ns(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn crypto_erase_supported(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_crypto_erase_supported(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 248u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 248u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(format_all_ns: u8, erase_all_ns: u8,
                          crypto_erase_supported: u8, reserved: u8) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((format_all_ns as u8 as u8) << 0usize) &
                                (1u64 as u8))
                   } | ((erase_all_ns as u8 as u8) << 1usize) & (2u64 as u8))
              } |
                  ((crypto_erase_supported as u8 as u8) << 2usize) &
                      (4u64 as u8))
         } | ((reserved as u8 as u8) << 3usize) & (248u64 as u8))
    }
}
/// volatile write cache
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_17 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_17>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_17
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_17>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_17 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_17 {
    #[inline]
    pub fn present(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_present(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 254u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 254u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(present: u8, reserved: u8) -> u8 {
        ({ ({ 0 } | ((present as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((reserved as u8 as u8) << 1usize) & (254u64 as u8))
    }
}
/// SGL support
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_18 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_18>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_18
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_18>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_18 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_18 {
    #[inline]
    pub fn supported(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn keyed_sgl(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_keyed_sgl(&mut self, val: u32) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65528u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        let mask = 65528u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bit_bucket_descriptor(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65536u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bit_bucket_descriptor(&mut self, val: u32) {
        let mask = 65536u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn metadata_pointer(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 131072u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_metadata_pointer(&mut self, val: u32) {
        let mask = 131072u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn oversized_sgl(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 262144u64 as u32;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_oversized_sgl(&mut self, val: u32) {
        let mask = 262144u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn metadata_address(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 524288u64 as u32;
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_metadata_address(&mut self, val: u32) {
        let mask = 524288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn sgl_offset(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1048576u64 as u32;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sgl_offset(&mut self, val: u32) {
        let mask = 1048576u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4292870144u64 as u32;
        let val = (unit_field_val & mask) >> 21usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        let mask = 4292870144u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 21usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(supported: u32, reserved0: u32, keyed_sgl: u32,
                          reserved1: u32, bit_bucket_descriptor: u32,
                          metadata_pointer: u32, oversized_sgl: u32,
                          metadata_address: u32, sgl_offset: u32,
                          reserved2: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({ 0 } |
                                                          ((supported as u32
                                                                as u32) <<
                                                               0usize) &
                                                              (1u64 as u32))
                                                 } |
                                                     ((reserved0 as u32 as
                                                           u32) << 1usize) &
                                                         (2u64 as u32))
                                            } |
                                                ((keyed_sgl as u32 as u32) <<
                                                     2usize) & (4u64 as u32))
                                       } |
                                           ((reserved1 as u32 as u32) <<
                                                3usize) & (65528u64 as u32))
                                  } |
                                      ((bit_bucket_descriptor as u32 as u32)
                                           << 16usize) & (65536u64 as u32))
                             } |
                                 ((metadata_pointer as u32 as u32) << 17usize)
                                     & (131072u64 as u32))
                        } |
                            ((oversized_sgl as u32 as u32) << 18usize) &
                                (262144u64 as u32))
                   } |
                       ((metadata_address as u32 as u32) << 19usize) &
                           (524288u64 as u32))
              } |
                  ((sgl_offset as u32 as u32) << 20usize) &
                      (1048576u64 as u32))
         } | ((reserved2 as u32 as u32) << 21usize) & (4292870144u64 as u32))
    }
}
/// NVMe over Fabrics-specific fields
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_19 {
    /// I/O queue command capsule supported size (16-byte units)
    pub ioccsz: u32,
    /// I/O queue response capsule supported size (16-byte units)
    pub iorcsz: u32,
    /// In-capsule data offset (16-byte units)
    pub icdoff: u16,
    pub ctrattr: spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1,
    /// Maximum SGL block descriptors (0 = no limit)
    pub msdbd: u8,
    pub reserved: [u8; 244usize],
}
/// Controller attributes
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn ctrlr_model(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ctrlr_model(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 254u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 254u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ctrlr_model: u8, reserved: u8) -> u8 {
        ({ ({ 0 } | ((ctrlr_model as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((reserved as u8 as u8) << 1usize) & (254u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_19>() ,
               256usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_19>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_19 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) .
                ioccsz as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_19 ) , "::" , stringify ! (
                ioccsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) .
                iorcsz as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_19 ) , "::" , stringify ! (
                iorcsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) .
                icdoff as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_19 ) , "::" , stringify ! (
                icdoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) .
                ctrattr as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_19 ) , "::" , stringify ! (
                ctrattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) .
                msdbd as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_19 ) , "::" , stringify ! (
                msdbd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) .
                reserved as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ctrlr_data__bindgen_ty_19 ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for spdk_nvme_ctrlr_data__bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_data>() , 4096usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_data>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . vid as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( vid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . ssvid as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( ssvid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . sn as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( sn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . mn as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( mn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . fr as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( fr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . rab as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( rab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . ieee as *
                const _ as usize } , 73usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( ieee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . cmic as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( cmic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . mdts as *
                const _ as usize } , 77usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( mdts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . cntlid as *
                const _ as usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( cntlid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . ver as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . rtd3r as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( rtd3r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . rtd3e as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( rtd3e ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . oaes as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( oaes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . ctratt as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( ctratt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved_100
                as * const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved_100 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . fguid as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( fguid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved_128
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved_128 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . oacs as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( oacs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . acl as * const
                _ as usize } , 258usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( acl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . aerl as *
                const _ as usize } , 259usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( aerl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . frmw as *
                const _ as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( frmw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . lpa as * const
                _ as usize } , 261usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( lpa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . elpe as *
                const _ as usize } , 262usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( elpe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . npss as *
                const _ as usize } , 263usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( npss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . avscc as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( avscc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . apsta as *
                const _ as usize } , 265usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( apsta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . wctemp as *
                const _ as usize } , 266usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( wctemp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . cctemp as *
                const _ as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( cctemp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . mtfa as *
                const _ as usize } , 270usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( mtfa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . hmpre as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( hmpre ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . hmmin as *
                const _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( hmmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . tnvmcap as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( tnvmcap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . unvmcap as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( unvmcap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . rpmbs as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( rpmbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . edstt as *
                const _ as usize } , 316usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( edstt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . dsto as *
                const _ as usize } , 318usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( dsto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . fwug as *
                const _ as usize } , 319usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( fwug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . kas as * const
                _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( kas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . hctma as *
                const _ as usize } , 322usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( hctma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . mntmt as *
                const _ as usize } , 324usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( mntmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . mxtmt as *
                const _ as usize } , 326usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( mxtmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . sanicap as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( sanicap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved3 as *
                const _ as usize } , 332usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . sqes as *
                const _ as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( sqes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . cqes as *
                const _ as usize } , 513usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( cqes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . maxcmd as *
                const _ as usize } , 514usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( maxcmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . nn as * const
                _ as usize } , 516usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( nn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . oncs as *
                const _ as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( oncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . fuses as *
                const _ as usize } , 522usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( fuses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . fna as * const
                _ as usize } , 524usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( fna ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . vwc as * const
                _ as usize } , 525usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( vwc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . awun as *
                const _ as usize } , 526usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( awun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . awupf as *
                const _ as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( awupf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . nvscc as *
                const _ as usize } , 530usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( nvscc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved531 as
                * const _ as usize } , 531usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved531 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . acwu as *
                const _ as usize } , 532usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( acwu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved534 as
                * const _ as usize } , 534usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved534 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . sgls as *
                const _ as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( sgls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved4 as *
                const _ as usize } , 540usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . subnqn as *
                const _ as usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( subnqn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . reserved5 as *
                const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . nvmf_specific
                as * const _ as usize } , 1792usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( nvmf_specific ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . psd as * const
                _ as usize } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( psd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_data ) ) . vs as * const
                _ as usize } , 3072usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_data )
                , "::" , stringify ! ( vs ) ));
}
impl Clone for spdk_nvme_ctrlr_data {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ctrlr_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_ns_data {
    /// namespace size
    pub nsze: u64,
    /// namespace capacity
    pub ncap: u64,
    /// namespace utilization
    pub nuse: u64,
    pub nsfeat: spdk_nvme_ns_data__bindgen_ty_1,
    /// number of lba formats
    pub nlbaf: u8,
    pub flbas: spdk_nvme_ns_data__bindgen_ty_2,
    pub mc: spdk_nvme_ns_data__bindgen_ty_3,
    pub dpc: spdk_nvme_ns_data__bindgen_ty_4,
    pub dps: spdk_nvme_ns_data__bindgen_ty_5,
    pub nmic: spdk_nvme_ns_data__bindgen_ty_6,
    pub nsrescap: spdk_nvme_ns_data__bindgen_ty_7,
    pub fpi: spdk_nvme_ns_data__bindgen_ty_8,
    pub dlfeat: spdk_nvme_ns_data__bindgen_ty_9,
    /// namespace atomic write unit normal
    pub nawun: u16,
    /// namespace atomic write unit power fail
    pub nawupf: u16,
    /// namespace atomic compare & write unit
    pub nacwu: u16,
    /// namespace atomic boundary size normal
    pub nabsn: u16,
    /// namespace atomic boundary offset
    pub nabo: u16,
    /// namespace atomic boundary size power fail
    pub nabspf: u16,
    /// namespace optimal I/O boundary in logical blocks
    pub noiob: u16,
    /// NVM capacity
    pub nvmcap: [u64; 2usize],
    pub reserved64: [u8; 40usize],
    /// namespace globally unique identifier
    pub nguid: [u8; 16usize],
    /// IEEE extended unique identifier
    pub eui64: u64,
    pub lbaf: [spdk_nvme_ns_data__bindgen_ty_10; 16usize],
    pub reserved6: [u8; 192usize],
    pub vendor_specific: [u8; 3712usize],
}
/// namespace features
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_1>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_1 {
    #[inline]
    pub fn thin_prov(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_thin_prov(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn ns_atomic_write_unit(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ns_atomic_write_unit(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn dealloc_or_unwritten_error(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_dealloc_or_unwritten_error(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn guid_never_reused(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_guid_never_reused(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(thin_prov: u8, ns_atomic_write_unit: u8,
                          dealloc_or_unwritten_error: u8,
                          guid_never_reused: u8, reserved1: u8) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((thin_prov as u8 as u8) << 0usize) &
                                     (1u64 as u8))
                        } |
                            ((ns_atomic_write_unit as u8 as u8) << 1usize) &
                                (2u64 as u8))
                   } |
                       ((dealloc_or_unwritten_error as u8 as u8) << 2usize) &
                           (4u64 as u8))
              } | ((guid_never_reused as u8 as u8) << 3usize) & (8u64 as u8))
         } | ((reserved1 as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
/// formatted lba size
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_2 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_2>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_2>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_2 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_2 {
    #[inline]
    pub fn format(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_format(&mut self, val: u8) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn extended(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 224u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        let mask = 224u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(format: u8, extended: u8, reserved2: u8) -> u8 {
        ({
             ({ ({ 0 } | ((format as u8 as u8) << 0usize) & (15u64 as u8)) } |
                  ((extended as u8 as u8) << 4usize) & (16u64 as u8))
         } | ((reserved2 as u8 as u8) << 5usize) & (224u64 as u8))
    }
}
/// metadata capabilities
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_3 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_3>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_3 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_3>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_3 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_3 {
    #[inline]
    pub fn extended(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn pointer(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pointer(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 252u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        let mask = 252u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(extended: u8, pointer: u8, reserved3: u8) -> u8 {
        ({
             ({ ({ 0 } | ((extended as u8 as u8) << 0usize) & (1u64 as u8)) }
                  | ((pointer as u8 as u8) << 1usize) & (2u64 as u8))
         } | ((reserved3 as u8 as u8) << 2usize) & (252u64 as u8))
    }
}
/// end-to-end data protection capabilities
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_4 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_4>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_4 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_4>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_4 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_4 {
    #[inline]
    pub fn pit1(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pit1(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn pit2(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pit2(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn pit3(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pit3(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn md_start(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_md_start(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn md_end(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_md_end(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pit1: u8, pit2: u8, pit3: u8, md_start: u8,
                          md_end: u8) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((pit1 as u8 as u8) << 0usize) &
                                     (1u64 as u8))
                        } | ((pit2 as u8 as u8) << 1usize) & (2u64 as u8))
                   } | ((pit3 as u8 as u8) << 2usize) & (4u64 as u8))
              } | ((md_start as u8 as u8) << 3usize) & (8u64 as u8))
         } | ((md_end as u8 as u8) << 4usize) & (16u64 as u8))
    }
}
/// end-to-end data protection type settings
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_5 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_5>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_5 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_5>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_5 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_5 {
    #[inline]
    pub fn pit(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 7u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pit(&mut self, val: u8) {
        let mask = 7u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn md_start(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_md_start(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pit: u8, md_start: u8, reserved4: u8) -> u8 {
        ({
             ({ ({ 0 } | ((pit as u8 as u8) << 0usize) & (7u64 as u8)) } |
                  ((md_start as u8 as u8) << 3usize) & (8u64 as u8))
         } | ((reserved4 as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
/// namespace multi-path I/O and namespace sharing capabilities
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_6 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_6>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_6 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_6>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_6 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_6 {
    #[inline]
    pub fn can_share(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_can_share(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 254u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 254u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(can_share: u8, reserved: u8) -> u8 {
        ({ ({ 0 } | ((can_share as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((reserved as u8 as u8) << 1usize) & (254u64 as u8))
    }
}
/// reservation capabilities
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_ns_data__bindgen_ty_7 {
    pub rescap: spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1,
    pub raw: u8,
    _bindgen_union_align: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn persist(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_persist(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn write_exclusive(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_write_exclusive(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn exclusive_access(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_exclusive_access(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn write_exclusive_reg_only(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_write_exclusive_reg_only(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn exclusive_access_reg_only(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_exclusive_access_reg_only(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn write_exclusive_all_reg(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_write_exclusive_all_reg(&mut self, val: u8) {
        let mask = 32u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn exclusive_access_all_reg(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 64u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_exclusive_access_all_reg(&mut self, val: u8) {
        let mask = 64u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn ignore_existing_key(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 128u64 as u8;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ignore_existing_key(&mut self, val: u8) {
        let mask = 128u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(persist: u8, write_exclusive: u8,
                          exclusive_access: u8, write_exclusive_reg_only: u8,
                          exclusive_access_reg_only: u8,
                          write_exclusive_all_reg: u8,
                          exclusive_access_all_reg: u8,
                          ignore_existing_key: u8) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((persist as u8 as u8) <<
                                                     0usize) & (1u64 as u8))
                                       } |
                                           ((write_exclusive as u8 as u8) <<
                                                1usize) & (2u64 as u8))
                                  } |
                                      ((exclusive_access as u8 as u8) <<
                                           2usize) & (4u64 as u8))
                             } |
                                 ((write_exclusive_reg_only as u8 as u8) <<
                                      3usize) & (8u64 as u8))
                        } |
                            ((exclusive_access_reg_only as u8 as u8) <<
                                 4usize) & (16u64 as u8))
                   } |
                       ((write_exclusive_all_reg as u8 as u8) << 5usize) &
                           (32u64 as u8))
              } |
                  ((exclusive_access_all_reg as u8 as u8) << 6usize) &
                      (64u64 as u8))
         } | ((ignore_existing_key as u8 as u8) << 7usize) & (128u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_7>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_7>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data__bindgen_ty_7 ) ) .
                rescap as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_7 ) , "::" , stringify ! (
                rescap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data__bindgen_ty_7 ) ) . raw
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_7 ) , "::" , stringify ! ( raw )
                ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ns_data__bindgen_ty_7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// format progress indicator
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_8 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_8>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_8 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_8>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_8 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_8 {
    #[inline]
    pub fn percentage_remaining(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 127u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_percentage_remaining(&mut self, val: u8) {
        let mask = 127u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn fpi_supported(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 128u64 as u8;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_fpi_supported(&mut self, val: u8) {
        let mask = 128u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(percentage_remaining: u8, fpi_supported: u8) -> u8 {
        ({
             ({ 0 } |
                  ((percentage_remaining as u8 as u8) << 0usize) &
                      (127u64 as u8))
         } | ((fpi_supported as u8 as u8) << 7usize) & (128u64 as u8))
    }
}
/// deallocate logical features
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_ns_data__bindgen_ty_9 {
    pub raw: u8,
    pub bits: spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn read_value(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 7u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_read_value(&mut self, val: u8) {
        let mask = 7u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn write_zero_deallocate(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_write_zero_deallocate(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn guard_value(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_guard_value(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 224u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 224u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(read_value: u8, write_zero_deallocate: u8,
                          guard_value: u8, reserved: u8) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((read_value as u8 as u8) << 0usize) &
                                (7u64 as u8))
                   } |
                       ((write_zero_deallocate as u8 as u8) << 3usize) &
                           (8u64 as u8))
              } | ((guard_value as u8 as u8) << 4usize) & (16u64 as u8))
         } | ((reserved as u8 as u8) << 5usize) & (224u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_9>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_9>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data__bindgen_ty_9 ) ) . raw
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_9 ) , "::" , stringify ! ( raw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data__bindgen_ty_9 ) ) .
                bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_9 ) , "::" , stringify ! ( bits
                ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ns_data__bindgen_ty_9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// lba format support
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_ns_data__bindgen_ty_10 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_10>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_10 )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_10>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_ns_data__bindgen_ty_10 ) ));
}
impl Clone for spdk_nvme_ns_data__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_ns_data__bindgen_ty_10 {
    #[inline]
    pub fn ms(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65535u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ms(&mut self, val: u32) {
        let mask = 65535u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn lbads(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lbads(&mut self, val: u32) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn rp(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 50331648u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rp(&mut self, val: u32) {
        let mask = 50331648u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4227858432u64 as u32;
        let val = (unit_field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        let mask = 4227858432u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 26usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ms: u32, lbads: u32, rp: u32, reserved6: u32)
     -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((ms as u32 as u32) << 0usize) &
                                (65535u64 as u32))
                   } |
                       ((lbads as u32 as u32) << 16usize) &
                           (16711680u64 as u32))
              } | ((rp as u32 as u32) << 24usize) & (50331648u64 as u32))
         } | ((reserved6 as u32 as u32) << 26usize) & (4227858432u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_data>() , 4096usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_data>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nsze as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nsze ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . ncap as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( ncap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nuse as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nuse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nsfeat as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nsfeat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nlbaf as * const
                _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nlbaf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . flbas as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( flbas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . mc as * const _
                as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( mc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . dpc as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( dpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . dps as * const _
                as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( dps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nmic as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nmic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nsrescap as *
                const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nsrescap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . fpi as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( fpi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . dlfeat as * const
                _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( dlfeat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nawun as * const
                _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nawun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nawupf as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nawupf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nacwu as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nacwu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nabsn as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nabsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nabo as * const _
                as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nabo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nabspf as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nabspf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . noiob as * const
                _ as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( noiob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nvmcap as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nvmcap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . reserved64 as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( reserved64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . nguid as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( nguid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . eui64 as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( eui64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . lbaf as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( lbaf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . reserved6 as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_data ) ) . vendor_specific
                as * const _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_data ) ,
                "::" , stringify ! ( vendor_specific ) ));
}
impl Clone for spdk_nvme_ns_data {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ns_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/// Deallocated logical block features - read value
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_dealloc_logical_block_read_value {
    SPDK_NVME_DEALLOC_NOT_REPORTED = 0,
    SPDK_NVME_DEALLOC_READ_00 = 1,
    SPDK_NVME_DEALLOC_READ_FF = 2,
}
#[repr(u32)]
/// Reservation Type Encoding
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_type {
    SPDK_NVME_RESERVE_WRITE_EXCLUSIVE = 1,
    SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS = 2,
    SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY = 3,
    SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY = 4,
    SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS = 5,
    SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS = 6,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_acquire_data {
    /// current reservation key
    pub crkey: u64,
    /// preempt reservation key
    pub prkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_acquire_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_acquire_data>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_acquire_data
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_acquire_data>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_acquire_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_acquire_data ) ) .
                crkey as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_acquire_data ) , "::" , stringify ! (
                crkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_acquire_data ) ) .
                prkey as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_acquire_data ) , "::" , stringify ! (
                prkey ) ));
}
impl Clone for spdk_nvme_reservation_acquire_data {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Reservation Acquire action
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_acquire_action {
    SPDK_NVME_RESERVE_ACQUIRE = 0,
    SPDK_NVME_RESERVE_PREEMPT = 1,
    SPDK_NVME_RESERVE_PREEMPT_ABORT = 2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_status_data {
    /// reservation action generation counter
    pub generation: u32,
    /// reservation type
    pub type_: u8,
    /// number of registered controllers
    pub nr_regctl: u16,
    pub reserved1: u16,
    /// persist through power loss state
    pub ptpl_state: u8,
    pub reserved: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_status_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_status_data>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_status_data )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_status_data>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_status_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                generation as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                generation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                type_ as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                nr_regctl as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                nr_regctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                reserved1 as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                ptpl_state as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                ptpl_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_status_data ) ) .
                reserved as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_status_data ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for spdk_nvme_reservation_status_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_ctrlr_data {
    pub ctrlr_id: u16,
    pub rcsts: spdk_nvme_reservation_ctrlr_data__bindgen_ty_1,
    pub reserved2: [u8; 5usize],
    /// host identifier
    pub host_id: u64,
    /// reservation key
    pub key: u64,
}
/// reservation status
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_ctrlr_data__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_ctrlr_data__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 254u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        let mask = 254u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(status: u8, reserved1: u8) -> u8 {
        ({ ({ 0 } | ((status as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((reserved1 as u8 as u8) << 1usize) & (254u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_ctrlr_data>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_ctrlr_data )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_ctrlr_data>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                ctrlr_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! (
                ctrlr_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                rcsts as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! (
                rcsts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                reserved2 as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! (
                reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                host_id as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! (
                host_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_ctrlr_data ) ) .
                key as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_ctrlr_data ) , "::" , stringify ! ( key
                ) ));
}
impl Clone for spdk_nvme_reservation_ctrlr_data {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Change persist through power loss state for
/// Reservation Register command
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_register_cptpl {
    SPDK_NVME_RESERVE_PTPL_NO_CHANGES = 0,
    SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON = 2,
    SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS = 3,
}
#[repr(u32)]
/// Registration action for Reservation Register command
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_register_action {
    SPDK_NVME_RESERVE_REGISTER_KEY = 0,
    SPDK_NVME_RESERVE_UNREGISTER_KEY = 1,
    SPDK_NVME_RESERVE_REPLACE_KEY = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_register_data {
    /// current reservation key
    pub crkey: u64,
    /// new reservation key
    pub nrkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_register_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_register_data>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_register_data
               ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_register_data>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_reservation_register_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_register_data ) ) .
                crkey as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_register_data ) , "::" , stringify ! (
                crkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_register_data ) ) .
                nrkey as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_register_data ) , "::" , stringify ! (
                nrkey ) ));
}
impl Clone for spdk_nvme_reservation_register_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_reservation_key_data {
    /// current reservation key
    pub crkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_key_data() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_reservation_key_data>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_reservation_key_data )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_reservation_key_data>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_reservation_key_data
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_reservation_key_data ) ) .
                crkey as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_reservation_key_data ) , "::" , stringify ! ( crkey
                ) ));
}
impl Clone for spdk_nvme_reservation_key_data {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Reservation Release action
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_reservation_release_action {
    SPDK_NVME_RESERVE_RELEASE = 0,
    SPDK_NVME_RESERVE_CLEAR = 1,
}
#[repr(u32)]
/// Log page identifiers for SPDK_NVME_OPC_GET_LOG_PAGE
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_log_page {
    SPDK_NVME_LOG_ERROR = 1,
    SPDK_NVME_LOG_HEALTH_INFORMATION = 2,
    SPDK_NVME_LOG_FIRMWARE_SLOT = 3,
    SPDK_NVME_LOG_CHANGED_NS_LIST = 4,
    SPDK_NVME_LOG_COMMAND_EFFECTS_LOG = 5,
    SPDK_NVME_LOG_DISCOVERY = 112,
    SPDK_NVME_LOG_RESERVATION_NOTIFICATION = 128,
}
/// Error information log page (\ref SPDK_NVME_LOG_ERROR)
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_error_information_entry {
    pub error_count: u64,
    pub sqid: u16,
    pub cid: u16,
    pub status: spdk_nvme_status,
    pub error_location: u16,
    pub lba: u64,
    pub nsid: u32,
    pub vendor_specific: u8,
    pub reserved: [u8; 35usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_error_information_entry() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_error_information_entry>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_error_information_entry )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_error_information_entry>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_error_information_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                error_count as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                error_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                sqid as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                sqid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                cid as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! ( cid
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                status as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                error_location as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                error_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                lba as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! ( lba
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                nsid as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                nsid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                vendor_specific as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                vendor_specific ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_error_information_entry ) ) .
                reserved as * const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_error_information_entry ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for spdk_nvme_error_information_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_error_information_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union spdk_nvme_critical_warning_state {
    pub raw: u8,
    pub bits: spdk_nvme_critical_warning_state__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_critical_warning_state__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_critical_warning_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_critical_warning_state__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_critical_warning_state__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_critical_warning_state__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_critical_warning_state__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_critical_warning_state__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_critical_warning_state__bindgen_ty_1 {
    #[inline]
    pub fn available_spare(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_available_spare(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn temperature(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_temperature(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn device_reliability(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_device_reliability(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn read_only(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_read_only(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn volatile_memory_backup(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_volatile_memory_backup(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 224u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 224u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(available_spare: u8, temperature: u8,
                          device_reliability: u8, read_only: u8,
                          volatile_memory_backup: u8, reserved: u8) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((available_spare as u8 as u8) <<
                                           0usize) & (1u64 as u8))
                             } |
                                 ((temperature as u8 as u8) << 1usize) &
                                     (2u64 as u8))
                        } |
                            ((device_reliability as u8 as u8) << 2usize) &
                                (4u64 as u8))
                   } | ((read_only as u8 as u8) << 3usize) & (8u64 as u8))
              } |
                  ((volatile_memory_backup as u8 as u8) << 4usize) &
                      (16u64 as u8))
         } | ((reserved as u8 as u8) << 5usize) & (224u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_critical_warning_state() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_critical_warning_state>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_critical_warning_state )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_critical_warning_state>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_critical_warning_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_critical_warning_state ) ) .
                raw as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_critical_warning_state ) , "::" , stringify ! ( raw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_critical_warning_state ) ) .
                bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_critical_warning_state ) , "::" , stringify ! ( bits
                ) ));
}
impl Clone for spdk_nvme_critical_warning_state {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_critical_warning_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// SMART / health information page (\ref SPDK_NVME_LOG_HEALTH_INFORMATION)
#[repr(C, packed)]
#[derive(Copy)]
pub struct spdk_nvme_health_information_page {
    pub critical_warning: spdk_nvme_critical_warning_state,
    pub temperature: u16,
    pub available_spare: u8,
    pub available_spare_threshold: u8,
    pub percentage_used: u8,
    pub reserved: [u8; 26usize],
    pub data_units_read: [u64; 2usize],
    pub data_units_written: [u64; 2usize],
    pub host_read_commands: [u64; 2usize],
    pub host_write_commands: [u64; 2usize],
    pub controller_busy_time: [u64; 2usize],
    pub power_cycles: [u64; 2usize],
    pub power_on_hours: [u64; 2usize],
    pub unsafe_shutdowns: [u64; 2usize],
    pub media_errors: [u64; 2usize],
    pub num_error_info_log_entries: [u64; 2usize],
    pub warning_temp_time: u32,
    pub critical_temp_time: u32,
    pub temp_sensor: [u16; 8usize],
    pub reserved2: [u8; 296usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_health_information_page() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_health_information_page>() ,
               512usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_health_information_page )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_health_information_page>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_health_information_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                critical_warning as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                critical_warning ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                temperature as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                temperature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                available_spare as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                available_spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                available_spare_threshold as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                available_spare_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                percentage_used as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                percentage_used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                reserved as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                data_units_read as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                data_units_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                data_units_written as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                data_units_written ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                host_read_commands as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                host_read_commands ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                host_write_commands as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                host_write_commands ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                controller_busy_time as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                controller_busy_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                power_cycles as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                power_cycles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                power_on_hours as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                power_on_hours ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                unsafe_shutdowns as * const _ as usize } , 144usize , concat !
                (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                unsafe_shutdowns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                media_errors as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                media_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                num_error_info_log_entries as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                num_error_info_log_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                warning_temp_time as * const _ as usize } , 192usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                warning_temp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                critical_temp_time as * const _ as usize } , 196usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                critical_temp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                temp_sensor as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                temp_sensor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_health_information_page ) ) .
                reserved2 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_health_information_page ) , "::" , stringify ! (
                reserved2 ) ));
}
impl Clone for spdk_nvme_health_information_page {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_health_information_page {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// Firmware slot information page (\ref SPDK_NVME_LOG_FIRMWARE_SLOT)
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_firmware_page {
    pub afi: spdk_nvme_firmware_page__bindgen_ty_1,
    pub reserved: [u8; 7usize],
    pub revision: [u64; 7usize],
    pub reserved2: [u8; 448usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_firmware_page__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_firmware_page__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_firmware_page__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               spdk_nvme_firmware_page__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_firmware_page__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                spdk_nvme_firmware_page__bindgen_ty_1 ) ));
}
impl Clone for spdk_nvme_firmware_page__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_firmware_page__bindgen_ty_1 {
    #[inline]
    pub fn slot(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 7u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_slot(&mut self, val: u8) {
        let mask = 7u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 248u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        let mask = 248u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(slot: u8, reserved: u8) -> u8 {
        ({ ({ 0 } | ((slot as u8 as u8) << 0usize) & (7u64 as u8)) } |
             ((reserved as u8 as u8) << 3usize) & (248u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_firmware_page() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_firmware_page>() , 512usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_firmware_page ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_firmware_page>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_firmware_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_firmware_page ) ) . afi as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_firmware_page
                ) , "::" , stringify ! ( afi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_firmware_page ) ) . reserved as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_firmware_page
                ) , "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_firmware_page ) ) . revision as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_firmware_page
                ) , "::" , stringify ! ( revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_firmware_page ) ) . reserved2
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_firmware_page
                ) , "::" , stringify ! ( reserved2 ) ));
}
impl Clone for spdk_nvme_firmware_page {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_firmware_page {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/// Namespace attachment Type Encoding
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_ns_attach_type {
    SPDK_NVME_NS_CTRLR_ATTACH = 0,
    SPDK_NVME_NS_CTRLR_DETACH = 1,
}
#[repr(u32)]
/// Namespace management Type Encoding
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_ns_management_type {
    SPDK_NVME_NS_MANAGEMENT_CREATE = 0,
    SPDK_NVME_NS_MANAGEMENT_DELETE = 1,
}
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_ns_list {
    pub ns_list: [u32; 1024usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_list() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_list>() , 4096usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_ns_list ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_list>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ns_list ) ) . ns_list as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ns_list ) ,
                "::" , stringify ! ( ns_list ) ));
}
impl Clone for spdk_nvme_ns_list {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ns_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/// Namespace identification descriptor type
///
/// \sa spdk_nvme_ns_id_desc
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_nidt {
    SPDK_NVME_NIDT_EUI64 = 1,
    SPDK_NVME_NIDT_NGUID = 2,
    SPDK_NVME_NIDT_UUID = 3,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct spdk_nvme_ns_id_desc {
    /// Namespace identifier type
    pub nidt: u8,
    /// Namespace identifier length (length of nid field)
    pub nidl: u8,
    pub reserved2: u8,
    pub reserved3: u8,
    /// Namespace identifier
    pub nid: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_id_desc() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ns_id_desc>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_ns_id_desc ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ns_id_desc>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_ns_id_desc ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_ctrlr_list {
    pub ctrlr_count: u16,
    pub ctrlr_list: [u16; 2047usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_list() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_list>() , 4096usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_list )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_list>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_ctrlr_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_list ) ) . ctrlr_count as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_list )
                , "::" , stringify ! ( ctrlr_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_list ) ) . ctrlr_list as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_list )
                , "::" , stringify ! ( ctrlr_list ) ));
}
impl Clone for spdk_nvme_ctrlr_list {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ctrlr_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_secure_erase_setting {
    SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE = 0,
    SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE = 1,
    SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_pi_location {
    SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL = 0,
    SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_pi_type {
    SPDK_NVME_FMT_NVM_PROTECTION_DISABLE = 0,
    SPDK_NVME_FMT_NVM_PROTECTION_TYPE1 = 1,
    SPDK_NVME_FMT_NVM_PROTECTION_TYPE2 = 2,
    SPDK_NVME_FMT_NVM_PROTECTION_TYPE3 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_metadata_setting {
    SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER = 0,
    SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA = 1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_format {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_format() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_format>() , 4usize , concat ! (
               "Size of: " , stringify ! ( spdk_nvme_format ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_format>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( spdk_nvme_format ) ));
}
impl Clone for spdk_nvme_format {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_format {
    #[inline]
    pub fn lbaf(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 15u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lbaf(&mut self, val: u32) {
        let mask = 15u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ms(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ms(&mut self, val: u32) {
        let mask = 16u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn pi(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 224u64 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pi(&mut self, val: u32) {
        let mask = 224u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn pil(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 256u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pil(&mut self, val: u32) {
        let mask = 256u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ses(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3584u64 as u32;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ses(&mut self, val: u32) {
        let mask = 3584u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294963200u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294963200u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(lbaf: u32, ms: u32, pi: u32, pil: u32, ses: u32,
                          reserved: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((lbaf as u32 as u32) << 0usize) &
                                          (15u64 as u32))
                             } |
                                 ((ms as u32 as u32) << 4usize) &
                                     (16u64 as u32))
                        } | ((pi as u32 as u32) << 5usize) & (224u64 as u32))
                   } | ((pil as u32 as u32) << 8usize) & (256u64 as u32))
              } | ((ses as u32 as u32) << 9usize) & (3584u64 as u32))
         } | ((reserved as u32 as u32) << 12usize) & (4294963200u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_protection_info {
    pub guard: u16,
    pub app_tag: u16,
    pub ref_tag: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_protection_info() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_protection_info>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_protection_info ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_protection_info>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_protection_info )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_protection_info ) ) . guard as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_protection_info ) , "::" , stringify ! ( guard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_protection_info ) ) . app_tag
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_protection_info ) , "::" , stringify ! ( app_tag )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_protection_info ) ) . ref_tag
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                spdk_nvme_protection_info ) , "::" , stringify ! ( ref_tag )
                ));
}
impl Clone for spdk_nvme_protection_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10: commit action
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_fw_commit_action {
    SPDK_NVME_FW_COMMIT_REPLACE_IMG = 0,
    SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG = 1,
    SPDK_NVME_FW_COMMIT_ENABLE_IMG = 2,
    SPDK_NVME_FW_COMMIT_RUN_IMG = 3,
}
/// Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct spdk_nvme_fw_commit {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_fw_commit() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_fw_commit>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( spdk_nvme_fw_commit ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_fw_commit>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_fw_commit ) ));
}
impl Clone for spdk_nvme_fw_commit {
    fn clone(&self) -> Self { *self }
}
impl spdk_nvme_fw_commit {
    #[inline]
    pub fn fs(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 7u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_fs(&mut self, val: u32) {
        let mask = 7u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ca(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 56u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ca(&mut self, val: u32) {
        let mask = 56u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967232u64 as u32;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967232u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(fs: u32, ca: u32, reserved: u32) -> u32 {
        ({
             ({ ({ 0 } | ((fs as u32 as u32) << 0usize) & (7u64 as u32)) } |
                  ((ca as u32 as u32) << 3usize) & (56u64 as u32))
         } | ((reserved as u32 as u32) << 6usize) & (4294967232u64 as u32))
    }
}
#[repr(u32)]
/// Address family types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvmf_adrfam {
    SPDK_NVMF_ADRFAM_IPV4 = 1,
    SPDK_NVMF_ADRFAM_IPV6 = 2,
    SPDK_NVMF_ADRFAM_IB = 3,
    SPDK_NVMF_ADRFAM_FC = 4,
    SPDK_NVMF_ADRFAM_INTRA_HOST = 254,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr {
    _unused: [u8; 0],
}
/// \brief NVMe controller initialization options.
///
/// A pointer to this structure will be provided for each probe callback from spdk_nvme_probe() to
/// allow the user to request non-default options, and the actual options enabled on the controller
/// will be provided during the attach callback.
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_ctrlr_opts {
    /// Number of I/O queues to request (used to set Number of Queues feature)
    pub num_io_queues: u32,
    /// Enable submission queue in controller memory buffer
    pub use_cmb_sqs: bool,
    /// Type of arbitration mechanism
    pub arb_mechanism: spdk_nvme_cc_ams,
    /// Keep alive timeout in milliseconds (0 = disabled).
    ///
    /// The NVMe library will set the Keep Alive Timer feature to this value and automatically
    /// send Keep Alive commands as needed.  The library user must call
    /// spdk_nvme_ctrlr_process_admin_completions() periodically to ensure Keep Alive commands
    /// are sent.
    pub keep_alive_timeout_ms: u32,
    /// Specify the retry number when there is issue with the transport
    pub transport_retry_count: ::std::os::raw::c_int,
    /// The queue depth of each NVMe I/O queue.
    pub io_queue_size: u32,
    /// The host NQN to use when connecting to NVMe over Fabrics controllers.
    ///
    /// Unused for local PCIe-attached NVMe devices.
    pub hostnqn: [::std::os::raw::c_char; 224usize],
    /// The number of requests to allocate for each NVMe I/O queue.
    ///
    /// This should be at least as large as io_queue_size.
    ///
    /// A single I/O may allocate more than one request, since splitting may be necessary to
    /// conform to the device's maximum transfer size, PRP list compatibility requirements,
    /// or driver-assisted striping.
    pub io_queue_requests: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_opts() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_ctrlr_opts>() , 252usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_opts )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_ctrlr_opts>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_ctrlr_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . num_io_queues
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( num_io_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . use_cmb_sqs as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( use_cmb_sqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . arb_mechanism
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( arb_mechanism ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) .
                keep_alive_timeout_ms as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( keep_alive_timeout_ms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) .
                transport_retry_count as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( transport_retry_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . io_queue_size
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( io_queue_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) . hostnqn as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( hostnqn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_ctrlr_opts ) ) .
                io_queue_requests as * const _ as usize } , 248usize , concat
                ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_ctrlr_opts )
                , "::" , stringify ! ( io_queue_requests ) ));
}
impl Clone for spdk_nvme_ctrlr_opts {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_ctrlr_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
/// NVMe library transports
///
/// NOTE: These are mapped directly to the NVMe over Fabrics TRTYPE values, except for PCIe,
/// which is a special case since NVMe over Fabrics does not define a TRTYPE for local PCIe.
///
/// Currently, this uses 256 for PCIe which is intentionally outside of the 8-bit range of TRTYPE.
/// If the NVMe-oF specification ever defines a PCIe TRTYPE, this should be updated.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_transport_type {
    SPDK_NVME_TRANSPORT_PCIE = 256,
    SPDK_NVME_TRANSPORT_RDMA = 1,
}
/// NVMe transport identifier.
///
/// This identifies a unique endpoint on an NVMe fabric.
///
/// A string representation of a transport ID may be converted to this type using
/// spdk_nvme_transport_id_parse().
#[repr(C)]
#[derive(Copy)]
pub struct spdk_nvme_transport_id {
    /// NVMe transport type.
    pub trtype: spdk_nvme_transport_type,
    /// Address family of the transport address.
    ///
    /// For PCIe, this value is ignored.
    pub adrfam: spdk_nvmf_adrfam,
    /// Transport address of the NVMe-oF endpoint. For transports which use IP
    /// addressing (e.g. RDMA), this should be an IP address. For PCIe, this
    /// can either be a zero length string (the whole bus) or a PCI address
    /// in the format DDDD:BB:DD.FF or DDDD.BB.DD.FF
    pub traddr: [::std::os::raw::c_char; 257usize],
    /// Transport service id of the NVMe-oF endpoint.  For transports which use
    /// IP addressing (e.g. RDMA), this field shoud be the port number. For PCIe,
    /// this is always a zero length string.
    pub trsvcid: [::std::os::raw::c_char; 33usize],
    /// Subsystem NQN of the NVMe over Fabrics endpoint. May be a zero length string.
    pub subnqn: [::std::os::raw::c_char; 224usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_transport_id() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_transport_id>() , 524usize ,
               concat ! ( "Size of: " , stringify ! ( spdk_nvme_transport_id )
               ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_transport_id>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_transport_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . trtype as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( trtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . adrfam as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( adrfam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . traddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( traddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . trsvcid as *
                const _ as usize } , 265usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( trsvcid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_transport_id ) ) . subnqn as *
                const _ as usize } , 298usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_transport_id
                ) , "::" , stringify ! ( subnqn ) ));
}
impl Clone for spdk_nvme_transport_id {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_transport_id {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    /// Parse the string representation of a transport ID.
///
/// \param trid Output transport ID structure (must be allocated and initialized by caller).
/// \param str Input string representation of a transport ID to parse.
/// \return 0 if parsing was successful and trid is filled out, or negated errno values on failure.
///
/// str must be a zero-terminated C string containing one or more key:value pairs separated by
/// whitespace.
///
/// Key          | Value
/// ------------ | -----
/// trtype       | Transport type (e.g. PCIe, RDMA)
/// adrfam       | Address family (e.g. IPv4, IPv6)
/// traddr       | Transport address (e.g. 0000:04:00.0 for PCIe or 192.168.100.8 for RDMA)
/// trsvcid      | Transport service identifier (e.g. 4420)
/// subnqn       | Subsystem NQN
///
/// Unspecified fields of trid are left unmodified, so the caller must initialize trid (for example,
/// memset() to 0) before calling this function.
    pub fn spdk_nvme_transport_id_parse(trid: *mut spdk_nvme_transport_id,
                                        str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Parse the string representation of a transport ID tranport type.
///
/// \param trtype Output transport type (allocated by caller).
/// \param str Input string representation of transport type (e.g. "PCIe", "RDMA")
/// \return 0 if parsing was successful and trtype is filled out, or negated errno values on failure.
    pub fn spdk_nvme_transport_id_parse_trtype(trtype:
                                                   *mut spdk_nvme_transport_type,
                                               str:
                                                   *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Look up the string representation of a transport ID transport type.
///
/// \param trtype Transport type to convert.
/// \return Static string constant describing trtype, or NULL if trtype not found.
    pub fn spdk_nvme_transport_id_trtype_str(trtype: spdk_nvme_transport_type)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Look up the string representation of a transport ID address family.
///
/// \param adrfam Address family to convert.
/// \return Static string constant describing adrfam, or NULL if adrmfam not found.
    pub fn spdk_nvme_transport_id_adrfam_str(adrfam: spdk_nvmf_adrfam)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Parse the string representation of a tranport ID address family.
///
/// \param adrfam Output address family (allocated by caller).
/// \param str Input string representation of address family (e.g. "IPv4", "IPv6")
/// \return 0 if parsing was successful and adrfam is filled out, or negated errno values on failure.
    pub fn spdk_nvme_transport_id_parse_adrfam(adrfam: *mut spdk_nvmf_adrfam,
                                               str:
                                                   *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Compare two transport IDs.
///
/// \param trid1 First transport ID to compare.
/// \param trid2 Second transport ID to compare.
///
/// \return 0 if trid1 == trid2, less than 0 if trid1 < trid2, greater than 0 if trid1 > trid2.
///
/// The result of this function may be used to sort transport IDs in a consistent order; however,
/// the comparison result is not guaranteed to be consistent across library versions.
///
/// This function uses a case-insensitive comparison for string fields, but it does not otherwise
/// normalize the transport ID. It is the caller's responsibility to provide the transport IDs in
/// a consistent format.
    pub fn spdk_nvme_transport_id_compare(trid1:
                                              *const spdk_nvme_transport_id,
                                          trid2:
                                              *const spdk_nvme_transport_id)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type.
///
/// \param trtype NVMe over Fabrics transport type to check.
///
/// \return true if trtype is supported or false if it is not supported.
    pub fn spdk_nvme_transport_available(trtype: spdk_nvme_transport_type)
     -> bool;
}
/// Callback for spdk_nvme_probe() enumeration.
///
/// \param opts NVMe controller initialization options.  This structure will be populated with the
/// default values on entry, and the user callback may update any options to request a different
/// value.  The controller may not support all requested parameters, so the final values will be
/// provided during the attach callback.
/// \return true to attach to this device.
pub type spdk_nvme_probe_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               trid:
                                                   *const spdk_nvme_transport_id,
                                               opts:
                                                   *mut spdk_nvme_ctrlr_opts)
                              -> bool>;
/// Callback for spdk_nvme_probe() to report a device that has been attached to the userspace NVMe driver.
///
/// \param opts NVMe controller initialization options that were actually used.  Options may differ
/// from the requested options from the probe call depending on what the controller supports.
pub type spdk_nvme_attach_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               trid:
                                                   *const spdk_nvme_transport_id,
                                               ctrlr: *mut spdk_nvme_ctrlr,
                                               opts:
                                                   *const spdk_nvme_ctrlr_opts)>;
/// Callback for spdk_nvme_probe() to report that a device attached to the userspace NVMe driver
/// has been removed from the system.
///
/// The controller will remain in a failed state (any new I/O submitted will fail).
///
/// The controller must be detached from the userspace driver by calling spdk_nvme_detach()
/// once the controller is no longer in use.  It is up to the library user to ensure that
/// no other threads are using the controller before calling spdk_nvme_detach().
///
/// \param ctrlr NVMe controller instance that was removed.
pub type spdk_nvme_remove_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               ctrlr: *mut spdk_nvme_ctrlr)>;
extern "C" {
    /// \brief Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver
/// to each device found if desired.
///
/// \param trid The transport ID indicating which bus to enumerate. If the trtype is PCIe or trid is NULL,
/// this will scan the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the
/// location of an NVMe-oF discovery service.
/// \param cb_ctx Opaque value which will be passed back in cb_ctx parameter of the callbacks.
/// \param probe_cb will be called once per NVMe device found in the system.
/// \param attach_cb will be called for devices for which probe_cb returned true once that NVMe
/// controller has been attached to the userspace driver.
/// \param remove_cb will be called for devices that were attached in a previous spdk_nvme_probe()
/// call but are no longer attached to the system. Optional; specify NULL if removal notices are not
/// desired.
///
/// This function is not thread safe and should only be called from one thread at a time while no
/// other threads are actively using any NVMe devices.
///
/// If called from a secondary process, only devices that have been attached to the userspace driver
/// in the primary process will be probed.
///
/// If called more than once, only devices that are not already attached to the SPDK NVMe driver
/// will be reported.
///
/// To stop using the the controller and release its associated resources,
/// call \ref spdk_nvme_detach with the spdk_nvme_ctrlr instance returned by this function.
    pub fn spdk_nvme_probe(trid: *const spdk_nvme_transport_id,
                           cb_ctx: *mut ::std::os::raw::c_void,
                           probe_cb: spdk_nvme_probe_cb,
                           attach_cb: spdk_nvme_attach_cb,
                           remove_cb: spdk_nvme_remove_cb)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Detaches specified device returned by \ref spdk_nvme_probe()'s attach_cb from the NVMe driver.
///
/// On success, the spdk_nvme_ctrlr handle is no longer valid.
///
/// This function should be called from a single thread while no other threads
/// are actively using the NVMe device.
///
    pub fn spdk_nvme_detach(ctrlr: *mut spdk_nvme_ctrlr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Perform a full hardware reset of the NVMe controller.
///
/// This function should be called from a single thread while no other threads
/// are actively using the NVMe device.
///
/// Any pointers returned from spdk_nvme_ctrlr_get_ns() and spdk_nvme_ns_get_data() may be invalidated
/// by calling this function.  The number of namespaces as returned by spdk_nvme_ctrlr_get_num_ns() may
/// also change.
    pub fn spdk_nvme_ctrlr_reset(ctrlr: *mut spdk_nvme_ctrlr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the identify controller data as defined by the NVMe specification.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
    pub fn spdk_nvme_ctrlr_get_data(ctrlr: *mut spdk_nvme_ctrlr)
     -> *const spdk_nvme_ctrlr_data;
}
extern "C" {
    /// \brief Get the NVMe controller CSTS (Status) register.
    pub fn spdk_nvme_ctrlr_get_regs_csts(ctrlr: *mut spdk_nvme_ctrlr)
     -> spdk_nvme_csts_register;
}
extern "C" {
    /// \brief Get the NVMe controller CAP (Capabilities) register.
    pub fn spdk_nvme_ctrlr_get_regs_cap(ctrlr: *mut spdk_nvme_ctrlr)
     -> spdk_nvme_cap_register;
}
extern "C" {
    /// \brief Get the NVMe controller VS (Version) register.
    pub fn spdk_nvme_ctrlr_get_regs_vs(ctrlr: *mut spdk_nvme_ctrlr)
     -> spdk_nvme_vs_register;
}
extern "C" {
    /// \brief Get the number of namespaces for the given NVMe controller.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// This is equivalent to calling spdk_nvme_ctrlr_get_data() to get the
/// spdk_nvme_ctrlr_data and then reading the nn field.
///
    pub fn spdk_nvme_ctrlr_get_num_ns(ctrlr: *mut spdk_nvme_ctrlr) -> u32;
}
extern "C" {
    /// \brief Determine if a particular log page is supported by the given NVMe controller.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// \sa spdk_nvme_ctrlr_cmd_get_log_page()
    pub fn spdk_nvme_ctrlr_is_log_page_supported(ctrlr: *mut spdk_nvme_ctrlr,
                                                 log_page: u8) -> bool;
}
extern "C" {
    /// \brief Determine if a particular feature is supported by the given NVMe controller.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// \sa spdk_nvme_ctrlr_cmd_get_feature()
    pub fn spdk_nvme_ctrlr_is_feature_supported(ctrlr: *mut spdk_nvme_ctrlr,
                                                feature_code: u8) -> bool;
}
/// Signature for callback function invoked when a command is completed.
///
/// The spdk_nvme_cpl parameter contains the completion status.
pub type spdk_nvme_cmd_cb =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *const spdk_nvme_cpl)>;
/// Signature for callback function invoked when an asynchronous error
/// request command is completed.
///
/// The aer_cb_arg parameter is set to the context specified by
/// spdk_nvme_register_aer_callback().
/// The spdk_nvme_cpl parameter contains the completion status of the
/// asynchronous event request that was completed.
pub type spdk_nvme_aer_cb =
    ::std::option::Option<unsafe extern "C" fn(aer_cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               arg1: *const spdk_nvme_cpl)>;
extern "C" {
    pub fn spdk_nvme_ctrlr_register_aer_callback(ctrlr: *mut spdk_nvme_ctrlr,
                                                 aer_cb_fn: spdk_nvme_aer_cb,
                                                 aer_cb_arg:
                                                     *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_qpair {
    _unused: [u8; 0],
}
/// Signature for the callback function invoked when a timeout is
/// detected on a request.
/// For timeouts detected on the admin queue pair, the qpair returned
/// here will be NULL.
pub type spdk_nvme_timeout_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               ctrlr: *mut spdk_nvme_ctrlr,
                                               qpair: *mut spdk_nvme_qpair,
                                               cid: u16)>;
extern "C" {
    /// \brief Register for timeout callback on a controller.
///
/// The application can choose to register for timeout callback or not register
/// for timeout callback.
///
/// \param ctrlr NVMe controller on which to monitor for timeout.
/// \param timeout_sec Timeout value in seconds.
/// \param cb_fn A function pointer that points to the callback function
/// \param cb_arg Argument to the callback function.
    pub fn spdk_nvme_ctrlr_register_timeout_callback(ctrlr:
                                                         *mut spdk_nvme_ctrlr,
                                                     timeout_sec: u32,
                                                     cb_fn:
                                                         spdk_nvme_timeout_cb,
                                                     cb_arg:
                                                         *mut ::std::os::raw::c_void);
}
/// \brief NVMe I/O queue pair initialization options.
///
/// These options may be passed to spdk_nvme_ctrlr_alloc_io_qpair() to configure queue pair
/// options at queue creation time.
///
/// The user may retrieve the default I/O queue pair creation options for a controller using
/// spdk_nvme_ctrlr_get_default_io_qpair_opts().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct spdk_nvme_io_qpair_opts {
    /// Queue priority for weighted round robin arbitration.  If a different arbitration
    /// method is in use, pass 0.
    pub qprio: spdk_nvme_qprio,
    /// The queue depth of this NVMe I/O queue. Overrides spdk_nvme_ctrlr_opts::io_queue_size.
    pub io_queue_size: u32,
    /// The number of requests to allocate for this NVMe I/O queue.
    ///
    /// Overrides spdk_nvme_ctrlr_opts::io_queue_requests.
    ///
    /// This should be at least as large as io_queue_size.
    ///
    /// A single I/O may allocate more than one request, since splitting may be necessary to
    /// conform to the device's maximum transfer size, PRP list compatibility requirements,
    /// or driver-assisted striping.
    pub io_queue_requests: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_io_qpair_opts() {
    assert_eq!(::std::mem::size_of::<spdk_nvme_io_qpair_opts>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( spdk_nvme_io_qpair_opts ) ));
    assert_eq! (::std::mem::align_of::<spdk_nvme_io_qpair_opts>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spdk_nvme_io_qpair_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_io_qpair_opts ) ) . qprio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_io_qpair_opts
                ) , "::" , stringify ! ( qprio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_io_qpair_opts ) ) .
                io_queue_size as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( spdk_nvme_io_qpair_opts
                ) , "::" , stringify ! ( io_queue_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spdk_nvme_io_qpair_opts ) ) .
                io_queue_requests as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( spdk_nvme_io_qpair_opts
                ) , "::" , stringify ! ( io_queue_requests ) ));
}
impl Clone for spdk_nvme_io_qpair_opts {
    fn clone(&self) -> Self { *self }
}
impl Default for spdk_nvme_io_qpair_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    /// \brief Get the default options for I/O qpair creation for a specific NVMe controller.
///
/// \param ctrlr NVMe controller to retrieve the defaults from.
/// \param[out] opts Will be filled with the default options for spdk_nvme_ctrlr_alloc_io_qpair().
/// \param opts_size Must be set to sizeof(struct spdk_nvme_io_qpair_opts).
    pub fn spdk_nvme_ctrlr_get_default_io_qpair_opts(ctrlr:
                                                         *mut spdk_nvme_ctrlr,
                                                     opts:
                                                         *mut spdk_nvme_io_qpair_opts,
                                                     opts_size: usize);
}
extern "C" {
    /// \brief Allocate an I/O queue pair (submission and completion queue).
///
/// Each queue pair should only be used from a single thread at a time (mutual exclusion must be
/// enforced by the user).
///
/// \param ctrlr NVMe controller for which to allocate the I/O queue pair.
/// \param opts I/O qpair creation options, or NULL to use the defaults as returned by
/// spdk_nvme_ctrlr_alloc_io_qpair().
/// \param opts_size Must be set to sizeof(struct spdk_nvme_io_qpair_opts), or 0 if opts is NULL.
    pub fn spdk_nvme_ctrlr_alloc_io_qpair(ctrlr: *mut spdk_nvme_ctrlr,
                                          opts:
                                              *const spdk_nvme_io_qpair_opts,
                                          opts_size: usize)
     -> *mut spdk_nvme_qpair;
}
extern "C" {
    /// \brief Free an I/O queue pair that was allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    pub fn spdk_nvme_ctrlr_free_io_qpair(qpair: *mut spdk_nvme_qpair)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Send the given NVM I/O command to the NVMe controller.
///
/// This is a low level interface for submitting I/O commands directly. Prefer
/// the spdk_nvme_ns_cmd_* functions instead. The validity of the command will
/// not be checked!
///
/// When constructing the nvme_command it is not necessary to fill out the PRP
/// list/SGL or the CID. The driver will handle both of those for you.
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ctrlr_cmd_io_raw(ctrlr: *mut spdk_nvme_ctrlr,
                                      qpair: *mut spdk_nvme_qpair,
                                      cmd: *mut spdk_nvme_cmd,
                                      buf: *mut ::std::os::raw::c_void,
                                      len: u32, cb_fn: spdk_nvme_cmd_cb,
                                      cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Process any outstanding completions for I/O submitted on a queue pair.
///
/// This call is non-blocking, i.e. it only
/// processes completions that are ready at the time of this function call. It does not
/// wait for outstanding commands to finish.
///
/// For each completed command, the request's callback function will
/// be called if specified as non-NULL when the request was submitted.
///
/// \param qpair Queue pair to check for completions.
/// \param max_completions Limit the number of completions to be processed in one call, or 0
/// for unlimited.
///
/// \return Number of completions processed (may be 0) or negative on error.
///
/// \sa spdk_nvme_cmd_cb
///
/// This function may be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// The caller must ensure that each queue pair is only used from one thread at a time.
    pub fn spdk_nvme_qpair_process_completions(qpair: *mut spdk_nvme_qpair,
                                               max_completions: u32) -> i32;
}
extern "C" {
    /// \brief Send the given admin command to the NVMe controller.
///
/// This is a low level interface for submitting admin commands directly. Prefer
/// the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will
/// not be checked!
///
/// When constructing the nvme_command it is not necessary to fill out the PRP
/// list/SGL or the CID. The driver will handle both of those for you.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
    pub fn spdk_nvme_ctrlr_cmd_admin_raw(ctrlr: *mut spdk_nvme_ctrlr,
                                         cmd: *mut spdk_nvme_cmd,
                                         buf: *mut ::std::os::raw::c_void,
                                         len: u32, cb_fn: spdk_nvme_cmd_cb,
                                         cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Process any outstanding completions for admin commands.
///
/// This will process completions for admin commands submitted on any thread.
///
/// This call is non-blocking, i.e. it only processes completions that are ready
/// at the time of this function call. It does not wait for outstanding commands to
/// finish.
///
/// \return Number of completions processed (may be 0) or negative on error.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ctrlr_process_admin_completions(ctrlr:
                                                         *mut spdk_nvme_ctrlr)
     -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns {
    _unused: [u8; 0],
}
extern "C" {
    /// \brief Get a handle to a namespace for the given controller.
///
/// Namespaces are numbered from 1 to the total number of namespaces. There will never
/// be any gaps in the numbering. The number of namespaces is obtained by calling
/// spdk_nvme_ctrlr_get_num_ns().
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ctrlr_get_ns(ctrlr: *mut spdk_nvme_ctrlr, ns_id: u32)
     -> *mut spdk_nvme_ns;
}
extern "C" {
    /// \brief Get a specific log page from the NVMe controller.
///
/// \param ctrlr NVMe controller to query.
/// \param log_page The log page identifier.
/// \param nsid Depending on the log page, this may be 0, a namespace identifier, or SPDK_NVME_GLOBAL_NS_TAG.
/// \param payload The pointer to the payload buffer.
/// \param payload_size The size of payload buffer.
/// \param offset Offset in bytes within the log page to start retrieving log page data.
/// May only be non-zero if the controller supports extended data for Get Log Page
/// as reported in the controller data log page attributes.
/// \param cb_fn Callback function to invoke when the log page has been retrieved.
/// \param cb_arg Argument to pass to the callback function.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
///
/// \sa spdk_nvme_ctrlr_is_log_page_supported()
    pub fn spdk_nvme_ctrlr_cmd_get_log_page(ctrlr: *mut spdk_nvme_ctrlr,
                                            log_page: u8, nsid: u32,
                                            payload:
                                                *mut ::std::os::raw::c_void,
                                            payload_size: u32, offset: u64,
                                            cb_fn: spdk_nvme_cmd_cb,
                                            cb_arg:
                                                *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Abort a specific previously-submitted NVMe command.
///
/// \param ctrlr NVMe controller to which the command was submitted.
/// \param qpair NVMe queue pair to which the command was submitted.
/// For admin commands, pass NULL for the qpair.
/// \param cid Command ID of the command to abort.
/// \param cb_fn Callback function to invoke when the abort has completed.
/// \param cb_arg Argument to pass to the callback function.\
///
/// \return 0 if successfully submitted, negated errno value otherwise.
///
/// \sa spdk_nvme_ctrlr_register_timeout_callback()
    pub fn spdk_nvme_ctrlr_cmd_abort(ctrlr: *mut spdk_nvme_ctrlr,
                                     qpair: *mut spdk_nvme_qpair, cid: u16,
                                     cb_fn: spdk_nvme_cmd_cb,
                                     cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set specific feature for the given NVMe controller.
///
/// \param ctrlr NVMe controller to manipulate.
/// \param feature The feature identifier.
/// \param cdw11 as defined by the specification for this command.
/// \param cdw12 as defined by the specification for this command.
/// \param payload The pointer to the payload buffer.
/// \param payload_size The size of payload buffer.
/// \param cb_fn Callback function to invoke when the feature has been set.
/// \param cb_arg Argument to pass to the callback function.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
///
/// \sa spdk_nvme_ctrlr_cmd_get_feature()
    pub fn spdk_nvme_ctrlr_cmd_set_feature(ctrlr: *mut spdk_nvme_ctrlr,
                                           feature: u8, cdw11: u32,
                                           cdw12: u32,
                                           payload:
                                               *mut ::std::os::raw::c_void,
                                           payload_size: u32,
                                           cb_fn: spdk_nvme_cmd_cb,
                                           cb_arg:
                                               *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get specific feature from given NVMe controller.
///
/// \param ctrlr NVMe controller to query.
/// \param feature The feature identifier.
/// \param cdw11 as defined by the specification for this command.
/// \param payload The pointer to the payload buffer.
/// \param payload_size The size of payload buffer.
/// \param cb_fn Callback function to invoke when the feature has been retrieved.
/// \param cb_arg Argument to pass to the callback function.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
///
/// \sa spdk_nvme_ctrlr_cmd_set_feature()
    pub fn spdk_nvme_ctrlr_cmd_get_feature(ctrlr: *mut spdk_nvme_ctrlr,
                                           feature: u8, cdw11: u32,
                                           payload:
                                               *mut ::std::os::raw::c_void,
                                           payload_size: u32,
                                           cb_fn: spdk_nvme_cmd_cb,
                                           cb_arg:
                                               *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Attach the specified namespace to controllers.
///
/// \param ctrlr NVMe controller to use for command submission.
/// \param nsid Namespace identifier for namespace to attach.
/// \param payload The pointer to the controller list.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point after spdk_nvme_attach().
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
    pub fn spdk_nvme_ctrlr_attach_ns(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32,
                                     payload: *mut spdk_nvme_ctrlr_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Detach the specified namespace from controllers.
///
/// \param ctrlr NVMe controller to use for command submission.
/// \param nsid Namespace ID to detach.
/// \param payload The pointer to the controller list.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point after spdk_nvme_attach().
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
    pub fn spdk_nvme_ctrlr_detach_ns(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32,
                                     payload: *mut spdk_nvme_ctrlr_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Create a namespace.
///
/// \param ctrlr NVMe controller to create namespace on.
/// \param payload The pointer to the NVMe namespace data.
///
/// \return Namespace ID (>= 1) if successfully created, or 0 if the request failed.
///
/// This function is thread safe and can be called at any point after spdk_nvme_attach().
    pub fn spdk_nvme_ctrlr_create_ns(ctrlr: *mut spdk_nvme_ctrlr,
                                     payload: *mut spdk_nvme_ns_data) -> u32;
}
extern "C" {
    /// \brief Delete a namespace.
///
/// \param ctrlr NVMe controller to delete namespace from.
/// \param nsid The namespace identifier.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point after spdk_nvme_attach().
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
    pub fn spdk_nvme_ctrlr_delete_ns(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Format NVM.
///
/// This function requests a low-level format of the media.
///
/// \param ctrlr NVMe controller to format.
/// \param nsid The namespace identifier.  May be SPDK_NVME_GLOBAL_NS_TAG to format all namespaces.
/// \param format The format information for the command.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point after spdk_nvme_attach().
    pub fn spdk_nvme_ctrlr_format(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32,
                                  format: *mut spdk_nvme_format)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Download a new firmware image.
///
/// \param payload The data buffer for the firmware image.
/// \param size The data size will be downloaded.
/// \param slot The slot that the firmware image will be committed to.
/// \param commit_action The action to perform when firmware is committed.
/// \param completion_status output parameter. Contains the completion status of the firmware commit operation.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request,
/// -1 if the size is not multiple of 4.
///
/// This function is thread safe and can be called at any point after spdk_nvme_attach().
    pub fn spdk_nvme_ctrlr_update_firmware(ctrlr: *mut spdk_nvme_ctrlr,
                                           payload:
                                               *mut ::std::os::raw::c_void,
                                           size: u32,
                                           slot: ::std::os::raw::c_int,
                                           commit_action:
                                               spdk_nvme_fw_commit_action,
                                           completion_status:
                                               *mut spdk_nvme_status)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the identify namespace data as defined by the NVMe specification.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_data(ns: *mut spdk_nvme_ns)
     -> *const spdk_nvme_ns_data;
}
extern "C" {
    /// \brief Get the namespace id (index number) from the given namespace handle.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_id(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// \brief Determine whether a namespace is active.
///
/// Inactive namespaces cannot be the target of I/O commands.
    pub fn spdk_nvme_ns_is_active(ns: *mut spdk_nvme_ns) -> bool;
}
extern "C" {
    /// \brief Get the maximum transfer size, in bytes, for an I/O sent to the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_max_io_xfer_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// \brief Get the sector size, in bytes, of the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_sector_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// \brief Get the number of sectors for the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_num_sectors(ns: *mut spdk_nvme_ns) -> u64;
}
extern "C" {
    /// \brief Get the size, in bytes, of the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_size(ns: *mut spdk_nvme_ns) -> u64;
}
extern "C" {
    /// \brief Get the end-to-end data protection information type of the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_pi_type(ns: *mut spdk_nvme_ns)
     -> spdk_nvme_pi_type;
}
extern "C" {
    /// \brief Get the metadata size, in bytes, of the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_md_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// \brief True if the namespace can support extended LBA when end-to-end data protection enabled.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_supports_extended_lba(ns: *mut spdk_nvme_ns) -> bool;
}
#[repr(u32)]
/// \brief Namespace command support flags.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spdk_nvme_ns_flags {
    SPDK_NVME_NS_DEALLOCATE_SUPPORTED = 1,
    SPDK_NVME_NS_FLUSH_SUPPORTED = 2,
    SPDK_NVME_NS_RESERVATION_SUPPORTED = 4,
    SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED = 8,
    SPDK_NVME_NS_DPS_PI_SUPPORTED = 16,
    SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED = 32,
}
extern "C" {
    /// \brief Get the flags for the given namespace.
///
/// See spdk_nvme_ns_flags for the possible flags returned.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
    pub fn spdk_nvme_ns_get_flags(ns: *mut spdk_nvme_ns) -> u32;
}
/// Restart the SGL walk to the specified offset when the command has scattered payloads.
///
/// The cb_arg parameter is the value passed to readv/writev.
pub type spdk_nvme_req_reset_sgl_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               offset: u32)>;
/// Fill out *address and *length with the current SGL entry and advance to the next
/// entry for the next time the callback is invoked.
///
/// The cb_arg parameter is the value passed to readv/writev.
/// The address parameter contains the virtual address of this segment.
/// The length parameter contains the length of this physical segment.
/// The described segment must be physically contiguous.
pub type spdk_nvme_req_next_sge_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               address:
                                                   *mut *mut ::std::os::raw::c_void,
                                               length: *mut u32)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// \brief Submits a write I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the write I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param lba starting LBA to write the data
/// \param lba_count length (in sectors) for the write operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
/// in spdk/nvme_spec.h, for this I/O.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_write(ns: *mut spdk_nvme_ns,
                                  qpair: *mut spdk_nvme_qpair,
                                  payload: *mut ::std::os::raw::c_void,
                                  lba: u64, lba_count: u32,
                                  cb_fn: spdk_nvme_cmd_cb,
                                  cb_arg: *mut ::std::os::raw::c_void,
                                  io_flags: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a write I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the write I/O
/// \param qpair I/O queue pair to submit the request
/// \param lba starting LBA to write the data
/// \param lba_count length (in sectors) for the write operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param reset_sgl_fn callback function to reset scattered payload
/// \param next_sge_fn callback function to iterate each scattered
/// payload memory segment
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_writev(ns: *mut spdk_nvme_ns,
                                   qpair: *mut spdk_nvme_qpair, lba: u64,
                                   lba_count: u32, cb_fn: spdk_nvme_cmd_cb,
                                   cb_arg: *mut ::std::os::raw::c_void,
                                   io_flags: u32,
                                   reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
                                   next_sge_fn: spdk_nvme_req_next_sge_cb)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a write I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the write I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param metadata virtual address pointer to the metadata payload, the length
/// of metadata is specified by spdk_nvme_ns_get_md_size()
/// \param lba starting LBA to write the data
/// \param lba_count length (in sectors) for the write operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
/// in spdk/nvme_spec.h, for this I/O.
/// \param apptag_mask application tag mask.
/// \param apptag application tag to use end-to-end protection information.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_write_with_md(ns: *mut spdk_nvme_ns,
                                          qpair: *mut spdk_nvme_qpair,
                                          payload:
                                              *mut ::std::os::raw::c_void,
                                          metadata:
                                              *mut ::std::os::raw::c_void,
                                          lba: u64, lba_count: u32,
                                          cb_fn: spdk_nvme_cmd_cb,
                                          cb_arg: *mut ::std::os::raw::c_void,
                                          io_flags: u32, apptag_mask: u16,
                                          apptag: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a write zeroes I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the write zeroes I/O
/// \param qpair I/O queue pair to submit the request
/// \param lba starting LBA for this command
/// \param lba_count length (in sectors) for the write zero operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
/// in spdk/nvme_spec.h, for this I/O.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_write_zeroes(ns: *mut spdk_nvme_ns,
                                         qpair: *mut spdk_nvme_qpair,
                                         lba: u64, lba_count: u32,
                                         cb_fn: spdk_nvme_cmd_cb,
                                         cb_arg: *mut ::std::os::raw::c_void,
                                         io_flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a read I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the read I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param lba starting LBA to read the data
/// \param lba_count length (in sectors) for the read operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_read(ns: *mut spdk_nvme_ns,
                                 qpair: *mut spdk_nvme_qpair,
                                 payload: *mut ::std::os::raw::c_void,
                                 lba: u64, lba_count: u32,
                                 cb_fn: spdk_nvme_cmd_cb,
                                 cb_arg: *mut ::std::os::raw::c_void,
                                 io_flags: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a read I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the read I/O
/// \param qpair I/O queue pair to submit the request
/// \param lba starting LBA to read the data
/// \param lba_count length (in sectors) for the read operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param reset_sgl_fn callback function to reset scattered payload
/// \param next_sge_fn callback function to iterate each scattered
/// payload memory segment
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_readv(ns: *mut spdk_nvme_ns,
                                  qpair: *mut spdk_nvme_qpair, lba: u64,
                                  lba_count: u32, cb_fn: spdk_nvme_cmd_cb,
                                  cb_arg: *mut ::std::os::raw::c_void,
                                  io_flags: u32,
                                  reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
                                  next_sge_fn: spdk_nvme_req_next_sge_cb)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a read I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the read I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param metadata virtual address pointer to the metadata payload, the length
/// of metadata is specified by spdk_nvme_ns_get_md_size()
/// \param lba starting LBA to read the data
/// \param lba_count length (in sectors) for the read operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param apptag_mask application tag mask.
/// \param apptag application tag to use end-to-end protection information.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_read_with_md(ns: *mut spdk_nvme_ns,
                                         qpair: *mut spdk_nvme_qpair,
                                         payload: *mut ::std::os::raw::c_void,
                                         metadata:
                                             *mut ::std::os::raw::c_void,
                                         lba: u64, lba_count: u32,
                                         cb_fn: spdk_nvme_cmd_cb,
                                         cb_arg: *mut ::std::os::raw::c_void,
                                         io_flags: u32, apptag_mask: u16,
                                         apptag: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a data set management request to the specified NVMe namespace. Data set
/// management operations are designed to optimize interaction with the block
/// translation layer inside the device. The most common type of operation is
/// deallocate, which is often referred to as TRIM or UNMAP.
///
/// \param ns NVMe namespace to submit the DSM request
/// \param type A bit field constructed from \ref enum spdk_nvme_dsm_attribute.
/// \param qpair I/O queue pair to submit the request
/// \param ranges An array of \ref spdk_nvme_dsm_range elements describing
/// the LBAs to operate on.
/// \param num_ranges The number of elements in the ranges array.
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, negated POSIX errno values otherwise.
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
///
/// This is a convenience wrapper that will automatically allocate and construct the correct
/// data buffers. Therefore, ranges does not need to be allocated from pinned memory and
/// can be placed on the stack. If a higher performance, zero-copy version of DSM is
/// required, simply build and submit a raw command using spdk_nvme_ctrlr_cmd_io_raw().
    pub fn spdk_nvme_ns_cmd_dataset_management(ns: *mut spdk_nvme_ns,
                                               qpair: *mut spdk_nvme_qpair,
                                               type_: u32,
                                               ranges:
                                                   *const spdk_nvme_dsm_range,
                                               num_ranges: u16,
                                               cb_fn: spdk_nvme_cmd_cb,
                                               cb_arg:
                                                   *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a flush request to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the flush request
/// \param qpair I/O queue pair to submit the request
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_flush(ns: *mut spdk_nvme_ns,
                                  qpair: *mut spdk_nvme_qpair,
                                  cb_fn: spdk_nvme_cmd_cb,
                                  cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a reservation register to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the reservation register request
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the reservation register data
/// \param ignore_key '1' the current reservation key check is disabled
/// \param action specifies the registration action
/// \param cptpl change the Persist Through Power Loss state
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_reservation_register(ns: *mut spdk_nvme_ns,
                                                 qpair: *mut spdk_nvme_qpair,
                                                 payload:
                                                     *mut spdk_nvme_reservation_register_data,
                                                 ignore_key: bool,
                                                 action:
                                                     spdk_nvme_reservation_register_action,
                                                 cptpl:
                                                     spdk_nvme_reservation_register_cptpl,
                                                 cb_fn: spdk_nvme_cmd_cb,
                                                 cb_arg:
                                                     *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a reservation release to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the reservation release request
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to current reservation key
/// \param ignore_key '1' the current reservation key check is disabled
/// \param action specifies the reservation release action
/// \param type reservation type for the namespace
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_reservation_release(ns: *mut spdk_nvme_ns,
                                                qpair: *mut spdk_nvme_qpair,
                                                payload:
                                                    *mut spdk_nvme_reservation_key_data,
                                                ignore_key: bool,
                                                action:
                                                    spdk_nvme_reservation_release_action,
                                                type_:
                                                    spdk_nvme_reservation_type,
                                                cb_fn: spdk_nvme_cmd_cb,
                                                cb_arg:
                                                    *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a reservation acquire to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the reservation acquire request
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to reservation acquire data
/// \param ignore_key '1' the current reservation key check is disabled
/// \param action specifies the reservation acquire action
/// \param type reservation type for the namespace
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_reservation_acquire(ns: *mut spdk_nvme_ns,
                                                qpair: *mut spdk_nvme_qpair,
                                                payload:
                                                    *mut spdk_nvme_reservation_acquire_data,
                                                ignore_key: bool,
                                                action:
                                                    spdk_nvme_reservation_acquire_action,
                                                type_:
                                                    spdk_nvme_reservation_type,
                                                cb_fn: spdk_nvme_cmd_cb,
                                                cb_arg:
                                                    *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a reservation report to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the reservation report request
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer for reservation status data
/// \param len length bytes for reservation status data structure
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_reservation_report(ns: *mut spdk_nvme_ns,
                                               qpair: *mut spdk_nvme_qpair,
                                               payload:
                                                   *mut ::std::os::raw::c_void,
                                               len: u32,
                                               cb_fn: spdk_nvme_cmd_cb,
                                               cb_arg:
                                                   *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a compare I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the compare I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param lba starting LBA to compare the data
/// \param lba_count length (in sectors) for the compare operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_compare(ns: *mut spdk_nvme_ns,
                                    qpair: *mut spdk_nvme_qpair,
                                    payload: *mut ::std::os::raw::c_void,
                                    lba: u64, lba_count: u32,
                                    cb_fn: spdk_nvme_cmd_cb,
                                    cb_arg: *mut ::std::os::raw::c_void,
                                    io_flags: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a compare I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the compare I/O
/// \param qpair I/O queue pair to submit the request
/// \param lba starting LBA to compare the data
/// \param lba_count length (in sectors) for the compare operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param reset_sgl_fn callback function to reset scattered payload
/// \param next_sge_fn callback function to iterate each scattered
/// payload memory segment
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_comparev(ns: *mut spdk_nvme_ns,
                                     qpair: *mut spdk_nvme_qpair, lba: u64,
                                     lba_count: u32, cb_fn: spdk_nvme_cmd_cb,
                                     cb_arg: *mut ::std::os::raw::c_void,
                                     io_flags: u32,
                                     reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
                                     next_sge_fn: spdk_nvme_req_next_sge_cb)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a compare I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the compare I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param metadata virtual address pointer to the metadata payload, the length
/// of metadata is specified by spdk_nvme_ns_get_md_size()
/// \param lba starting LBA to compare the data
/// \param lba_count length (in sectors) for the compare operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param apptag_mask application tag mask.
/// \param apptag application tag to use end-to-end protection information.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_compare_with_md(ns: *mut spdk_nvme_ns,
                                            qpair: *mut spdk_nvme_qpair,
                                            payload:
                                                *mut ::std::os::raw::c_void,
                                            metadata:
                                                *mut ::std::os::raw::c_void,
                                            lba: u64, lba_count: u32,
                                            cb_fn: spdk_nvme_cmd_cb,
                                            cb_arg:
                                                *mut ::std::os::raw::c_void,
                                            io_flags: u32, apptag_mask: u16,
                                            apptag: u16)
     -> ::std::os::raw::c_int;
}
